{"ast":null,"code":"import { isObservable, of } from 'rxjs';\nimport { D as DataSource } from './data-source-D34wiQZj.mjs';\nimport { InjectionToken } from '@angular/core';\n\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n  _data;\n  constructor(_data) {\n    super();\n    this._data = _data;\n  }\n  connect() {\n    return isObservable(this._data) ? this._data : of(this._data);\n  }\n  disconnect() {}\n}\n\n/** Indicates how a view was changed by a `_ViewRepeater`. */\nvar _ViewRepeaterOperation;\n(function (_ViewRepeaterOperation) {\n  /** The content of an existing view was replaced with another item. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\n  /** A new view was created with `createEmbeddedView`. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\n  /** The position of a view changed, but the content remains the same. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\n  /** A view was detached from the view container. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\n})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));\n/**\r\n * Injection token for `_ViewRepeater`. This token is for use by Angular Material only.\r\n * @docs-private\r\n */\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\n\n/**\r\n * A repeater that caches views when they are removed from a\r\n * `ViewContainerRef`. When new items are inserted into the container,\r\n * the repeater will reuse one of the cached views instead of creating a new\r\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\r\n * inserts.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\nclass _RecycleViewRepeaterStrategy {\n  /**\r\n   * The size of the cache used to store unused views.\r\n   * Setting the cache size to `0` will disable caching. Defaults to 20 views.\r\n   */\n  viewCacheSize = 20;\n  /**\r\n   * View cache that stores embedded view instances that have been previously stamped out,\r\n   * but don't are not currently rendered. The view repeater will reuse these views rather than\r\n   * creating brand new ones.\r\n   *\r\n   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\r\n   */\n  _viewCache = [];\n  /** Apply changes to the DOM. */\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        // Item added.\n        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n      } else if (currentIndex == null) {\n        // Item removed.\n        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        // Item moved.\n        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n  /**\r\n   * Inserts a view for a new item, either from the cache or by creating a new\r\n   * one. Returns `undefined` if the item was inserted into a cached view.\r\n   */\n  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n  }\n  /** Detaches the view at the given index and inserts into the view cache. */\n  _detachAndCacheView(index, viewContainerRef) {\n    const detachedView = viewContainerRef.detach(index);\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n  /** Moves view at the previous index to the current index. */\n  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n    const view = viewContainerRef.get(adjustedPreviousIndex);\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n  /**\r\n   * Cache the given detached view. If the cache is full, the view will be\r\n   * destroyed.\r\n   */\n  _maybeCacheView(view, viewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n  /** Inserts a recycled view from the cache at the given index. */\n  _insertViewFromCache(index, viewContainerRef) {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\nexport { ArrayDataSource as A, _RecycleViewRepeaterStrategy as _, _ViewRepeaterOperation as a, _VIEW_REPEATER_STRATEGY as b };","map":{"version":3,"names":["isObservable","of","D","DataSource","InjectionToken","ArrayDataSource","_data","constructor","connect","disconnect","_ViewRepeaterOperation","_VIEW_REPEATER_STRATEGY","_RecycleViewRepeaterStrategy","viewCacheSize","_viewCache","applyChanges","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","forEachOperation","record","adjustedPreviousIndex","currentIndex","view","operation","previousIndex","viewArgsFactory","_insertView","INSERTED","REPLACED","_detachAndCacheView","REMOVED","_moveView","MOVED","context","detach","destroy","value","cachedView","_insertViewFromCache","$implicit","undefined","viewArgs","createEmbeddedView","templateRef","index","detachedView","_maybeCacheView","get","move","length","push","indexOf","remove","pop","insert","A","_","a","b"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy-SfuyU210.mjs"],"sourcesContent":["import { isObservable, of } from 'rxjs';\r\nimport { D as DataSource } from './data-source-D34wiQZj.mjs';\r\nimport { InjectionToken } from '@angular/core';\r\n\r\n/** DataSource wrapper for a native array. */\r\nclass ArrayDataSource extends DataSource {\r\n    _data;\r\n    constructor(_data) {\r\n        super();\r\n        this._data = _data;\r\n    }\r\n    connect() {\r\n        return isObservable(this._data) ? this._data : of(this._data);\r\n    }\r\n    disconnect() { }\r\n}\r\n\r\n/** Indicates how a view was changed by a `_ViewRepeater`. */\r\nvar _ViewRepeaterOperation;\r\n(function (_ViewRepeaterOperation) {\r\n    /** The content of an existing view was replaced with another item. */\r\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\r\n    /** A new view was created with `createEmbeddedView`. */\r\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\r\n    /** The position of a view changed, but the content remains the same. */\r\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\r\n    /** A view was detached from the view container. */\r\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\r\n})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));\r\n/**\r\n * Injection token for `_ViewRepeater`. This token is for use by Angular Material only.\r\n * @docs-private\r\n */\r\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\r\n\r\n/**\r\n * A repeater that caches views when they are removed from a\r\n * `ViewContainerRef`. When new items are inserted into the container,\r\n * the repeater will reuse one of the cached views instead of creating a new\r\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\r\n * inserts.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\r\nclass _RecycleViewRepeaterStrategy {\r\n    /**\r\n     * The size of the cache used to store unused views.\r\n     * Setting the cache size to `0` will disable caching. Defaults to 20 views.\r\n     */\r\n    viewCacheSize = 20;\r\n    /**\r\n     * View cache that stores embedded view instances that have been previously stamped out,\r\n     * but don't are not currently rendered. The view repeater will reuse these views rather than\r\n     * creating brand new ones.\r\n     *\r\n     * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\r\n     */\r\n    _viewCache = [];\r\n    /** Apply changes to the DOM. */\r\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\r\n        // Rearrange the views to put them in the right location.\r\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\r\n            let view;\r\n            let operation;\r\n            if (record.previousIndex == null) {\r\n                // Item added.\r\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\r\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\r\n            }\r\n            else if (currentIndex == null) {\r\n                // Item removed.\r\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\r\n                operation = _ViewRepeaterOperation.REMOVED;\r\n            }\r\n            else {\r\n                // Item moved.\r\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = _ViewRepeaterOperation.MOVED;\r\n            }\r\n            if (itemViewChanged) {\r\n                itemViewChanged({\r\n                    context: view?.context,\r\n                    operation,\r\n                    record,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    detach() {\r\n        for (const view of this._viewCache) {\r\n            view.destroy();\r\n        }\r\n        this._viewCache = [];\r\n    }\r\n    /**\r\n     * Inserts a view for a new item, either from the cache or by creating a new\r\n     * one. Returns `undefined` if the item was inserted into a cached view.\r\n     */\r\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\r\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\r\n        if (cachedView) {\r\n            cachedView.context.$implicit = value;\r\n            return undefined;\r\n        }\r\n        const viewArgs = viewArgsFactory();\r\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\r\n    }\r\n    /** Detaches the view at the given index and inserts into the view cache. */\r\n    _detachAndCacheView(index, viewContainerRef) {\r\n        const detachedView = viewContainerRef.detach(index);\r\n        this._maybeCacheView(detachedView, viewContainerRef);\r\n    }\r\n    /** Moves view at the previous index to the current index. */\r\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\r\n        const view = viewContainerRef.get(adjustedPreviousIndex);\r\n        viewContainerRef.move(view, currentIndex);\r\n        view.context.$implicit = value;\r\n        return view;\r\n    }\r\n    /**\r\n     * Cache the given detached view. If the cache is full, the view will be\r\n     * destroyed.\r\n     */\r\n    _maybeCacheView(view, viewContainerRef) {\r\n        if (this._viewCache.length < this.viewCacheSize) {\r\n            this._viewCache.push(view);\r\n        }\r\n        else {\r\n            const index = viewContainerRef.indexOf(view);\r\n            // The host component could remove views from the container outside of\r\n            // the view repeater. It's unlikely this will occur, but just in case,\r\n            // destroy the view on its own, otherwise destroy it through the\r\n            // container to ensure that all the references are removed.\r\n            if (index === -1) {\r\n                view.destroy();\r\n            }\r\n            else {\r\n                viewContainerRef.remove(index);\r\n            }\r\n        }\r\n    }\r\n    /** Inserts a recycled view from the cache at the given index. */\r\n    _insertViewFromCache(index, viewContainerRef) {\r\n        const cachedView = this._viewCache.pop();\r\n        if (cachedView) {\r\n            viewContainerRef.insert(cachedView, index);\r\n        }\r\n        return cachedView || null;\r\n    }\r\n}\r\n\r\nexport { ArrayDataSource as A, _RecycleViewRepeaterStrategy as _, _ViewRepeaterOperation as a, _VIEW_REPEATER_STRATEGY as b };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}