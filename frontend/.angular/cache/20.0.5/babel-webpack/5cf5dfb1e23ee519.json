{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { i as isFakeMousedownFromScreenReader, a as isFakeTouchstartFromScreenReader } from './fake-event-detection-DWOdFTFz.mjs';\nimport { d as ALT, C as CONTROL, M as MAC_META, e as META, f as SHIFT } from './keycodes-CpHkExLC.mjs';\nimport { _ as _getEventTarget, a as _getShadowRoot } from './shadow-dom-B0oHn41l.mjs';\nimport { P as Platform } from './platform-DNDzkVcI.mjs';\nimport { n as normalizePassiveListenerOptions } from './passive-listeners-esHZRgIN.mjs';\nimport { a as coerceElement } from './element-x4z00URv.mjs';\n\n/**\r\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\r\n * options.\r\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\r\n * Default options for the InputModalityDetector.\r\n *\r\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\r\n * keyboard input modality) for two reasons:\r\n *\r\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\r\n *    in new tab', and are thus less representative of actual keyboard interaction.\r\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\r\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\r\n *    these keys so as to not update the input modality.\r\n *\r\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\r\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\r\n * distinguish between the two.\r\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]\n};\n/**\r\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\r\n * event to be attributed as mouse and not touch.\r\n *\r\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n * that a value of around 650ms seems appropriate.\r\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\r\n * Event listener options that enable capturing and also mark the listener as passive if the browser\r\n * supports it.\r\n */\nconst modalityEventListenerOptions = {\n  passive: true,\n  capture: true\n};\n/**\r\n * Service that detects the user's input modality.\r\n *\r\n * This service does not update the input modality when a user navigates with a screen reader\r\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\r\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\r\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\r\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\r\n * input interaction.\r\n *\r\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\r\n * update the input modality to keyboard, but in general this service's behavior is largely\r\n * undefined.\r\n */\nclass InputModalityDetector {\n  _platform = inject(Platform);\n  _listenerCleanups;\n  /** Emits whenever an input modality is detected. */\n  modalityDetected;\n  /** Emits when the input modality changes. */\n  modalityChanged;\n  /** The most recently detected input modality. */\n  get mostRecentModality() {\n    return this._modality.value;\n  }\n  /**\r\n   * The most recently detected input modality event target. Is null if no input modality has been\r\n   * detected or if the associated event target is null for some unknown reason.\r\n   */\n  _mostRecentTarget = null;\n  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n  _modality = new BehaviorSubject(null);\n  /** Options for this InputModalityDetector. */\n  _options;\n  /**\r\n   * The timestamp of the last touch input modality. Used to determine whether mousedown events\r\n   * should be attributed to mouse or touch.\r\n   */\n  _lastTouchMs = 0;\n  /**\r\n   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\r\n   * bound.\r\n   */\n  _onKeydown = event => {\n    // If this is one of the keys we should ignore, then ignore it and don't update the input\n    // modality to keyboard.\n    if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n      return;\n    }\n    this._modality.next('keyboard');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  /**\r\n   * Handles mousedown events. Must be an arrow function in order to preserve the context when it\r\n   * gets bound.\r\n   */\n  _onMousedown = event => {\n    // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n    // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n    // after the previous touch event.\n    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n      return;\n    }\n    // Fake mousedown events are fired by some screen readers when controls are activated by the\n    // screen reader. Attribute them to keyboard input modality.\n    this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  /**\r\n   * Handles touchstart events. Must be an arrow function in order to preserve the context when it\r\n   * gets bound.\r\n   */\n  _onTouchstart = event => {\n    // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n    // events are fired. Again, attribute to keyboard input modality.\n    if (isFakeTouchstartFromScreenReader(event)) {\n      this._modality.next('keyboard');\n      return;\n    }\n    // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n    // triggered via mouse vs touch.\n    this._lastTouchMs = Date.now();\n    this._modality.next('touch');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  constructor() {\n    const ngZone = inject(NgZone);\n    const document = inject(DOCUMENT);\n    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {\n      optional: true\n    });\n    this._options = {\n      ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n      ...options\n    };\n    // Skip the first emission as it's null.\n    this.modalityDetected = this._modality.pipe(skip(1));\n    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n    // If we're not in a browser, this service should do nothing, as there's no relevant input\n    // modality to detect.\n    if (this._platform.isBrowser) {\n      const renderer = inject(RendererFactory2).createRenderer(null, null);\n      this._listenerCleanups = ngZone.runOutsideAngular(() => {\n        return [renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions), renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions), renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions)];\n      });\n    }\n  }\n  ngOnDestroy() {\n    this._modality.complete();\n    this._listenerCleanups?.forEach(cleanup => cleanup());\n  }\n  static ɵfac = function InputModalityDetector_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InputModalityDetector)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InputModalityDetector,\n    factory: InputModalityDetector.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InputModalityDetector, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/** Detection mode used for attributing the origin of a focus event. */\nvar FocusMonitorDetectionMode;\n(function (FocusMonitorDetectionMode) {\n  /**\r\n   * Any mousedown, keydown, or touchstart event that happened in the previous\r\n   * tick or the current tick will be used to assign a focus event's origin (to\r\n   * either mouse, keyboard, or touch). This is the default option.\r\n   */\n  FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n  /**\r\n   * A focus event's origin is always attributed to the last corresponding\r\n   * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\r\n   */\n  FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\r\n * Event listener options that enable capturing and also\r\n * mark the listener as passive if the browser supports it.\r\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n  _ngZone = inject(NgZone);\n  _platform = inject(Platform);\n  _inputModalityDetector = inject(InputModalityDetector);\n  /** The focus origin that the next focus event is a result of. */\n  _origin = null;\n  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n  _lastFocusOrigin;\n  /** Whether the window has just been focused. */\n  _windowFocused = false;\n  /** The timeout id of the window focus timeout. */\n  _windowFocusTimeoutId;\n  /** The timeout id of the origin clearing timeout. */\n  _originTimeoutId;\n  /**\r\n   * Whether the origin was determined via a touch interaction. Necessary as properly attributing\r\n   * focus events to touch interactions requires special logic.\r\n   */\n  _originFromTouchInteraction = false;\n  /** Map of elements being monitored to their info. */\n  _elementInfo = new Map();\n  /** The number of elements currently being monitored. */\n  _monitoredElementCount = 0;\n  /**\r\n   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\r\n   * as well as the number of monitored elements that they contain. We have to treat focus/blur\r\n   * handlers differently from the rest of the events, because the browser won't emit events\r\n   * to the document when focus moves inside of a shadow root.\r\n   */\n  _rootNodeFocusListenerCount = new Map();\n  /**\r\n   * The specified detection mode, used for attributing the origin of a focus\r\n   * event.\r\n   */\n  _detectionMode;\n  /**\r\n   * Event listener for `focus` events on the window.\r\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n   */\n  _windowFocusListener = () => {\n    // Make a note of when the window regains focus, so we can\n    // restore the origin info for the focused element.\n    this._windowFocused = true;\n    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n  };\n  /** Used to reference correct document/window */\n  _document = inject(DOCUMENT);\n  /** Subject for stopping our InputModalityDetector subscription. */\n  _stopInputModalityDetector = new Subject();\n  constructor() {\n    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n      optional: true\n    });\n    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n  }\n  /**\r\n   * Event listener for `focus` and 'blur' events on the document.\r\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n   */\n  _rootNodeFocusAndBlurListener = event => {\n    const target = _getEventTarget(event);\n    // We need to walk up the ancestor chain in order to support `checkChildren`.\n    for (let element = target; element; element = element.parentElement) {\n      if (event.type === 'focus') {\n        this._onFocus(event, element);\n      } else {\n        this._onBlur(event, element);\n      }\n    }\n  };\n  monitor(element, checkChildren = false) {\n    const nativeElement = coerceElement(element);\n    // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n      // Note: we don't want the observable to emit at all so we don't pass any parameters.\n      return of();\n    }\n    // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n    // the shadow root, rather than the `document`, because the browser won't emit focus events\n    // to the `document`, if focus is moving within the same shadow root.\n    const rootNode = _getShadowRoot(nativeElement) || this._document;\n    const cachedInfo = this._elementInfo.get(nativeElement);\n    // Check if we're already monitoring this element.\n    if (cachedInfo) {\n      if (checkChildren) {\n        // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n        // observers into ones that behave as if `checkChildren` was turned on. We need a more\n        // robust solution.\n        cachedInfo.checkChildren = true;\n      }\n      return cachedInfo.subject;\n    }\n    // Create monitored element info.\n    const info = {\n      checkChildren: checkChildren,\n      subject: new Subject(),\n      rootNode\n    };\n    this._elementInfo.set(nativeElement, info);\n    this._registerGlobalListeners(info);\n    return info.subject;\n  }\n  stopMonitoring(element) {\n    const nativeElement = coerceElement(element);\n    const elementInfo = this._elementInfo.get(nativeElement);\n    if (elementInfo) {\n      elementInfo.subject.complete();\n      this._setClasses(nativeElement);\n      this._elementInfo.delete(nativeElement);\n      this._removeGlobalListeners(elementInfo);\n    }\n  }\n  focusVia(element, origin, options) {\n    const nativeElement = coerceElement(element);\n    const focusedElement = this._document.activeElement;\n    // If the element is focused already, calling `focus` again won't trigger the event listener\n    // which means that the focus classes won't be updated. If that's the case, update the classes\n    // directly without waiting for an event.\n    if (nativeElement === focusedElement) {\n      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n    } else {\n      this._setOrigin(origin);\n      // `focus` isn't available on the server\n      if (typeof nativeElement.focus === 'function') {\n        nativeElement.focus(options);\n      }\n    }\n  }\n  ngOnDestroy() {\n    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n  }\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  _getWindow() {\n    return this._document.defaultView || window;\n  }\n  _getFocusOrigin(focusEventTarget) {\n    if (this._origin) {\n      // If the origin was realized via a touch interaction, we need to perform additional checks\n      // to determine whether the focus origin should be attributed to touch or program.\n      if (this._originFromTouchInteraction) {\n        return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n      } else {\n        return this._origin;\n      }\n    }\n    // If the window has just regained focus, we can restore the most recent origin from before the\n    // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n    // focus. This typically means one of two things happened:\n    //\n    // 1) The element was programmatically focused, or\n    // 2) The element was focused via screen reader navigation (which generally doesn't fire\n    //    events).\n    //\n    // Because we can't distinguish between these two cases, we default to setting `program`.\n    if (this._windowFocused && this._lastFocusOrigin) {\n      return this._lastFocusOrigin;\n    }\n    // If the interaction is coming from an input label, we consider it a mouse interactions.\n    // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n    // our detection, because all our assumptions are for `mousedown`. We need to handle this\n    // special case, because it's very common for checkboxes and radio buttons.\n    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n      return 'mouse';\n    }\n    return 'program';\n  }\n  /**\r\n   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\r\n   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\r\n   * handle a focus event following a touch interaction, we need to determine whether (1) the focus\r\n   * event was directly caused by the touch interaction or (2) the focus event was caused by a\r\n   * subsequent programmatic focus call triggered by the touch interaction.\r\n   * @param focusEventTarget The target of the focus event under examination.\r\n   */\n  _shouldBeAttributedToTouch(focusEventTarget) {\n    // Please note that this check is not perfect. Consider the following edge case:\n    //\n    // <div #parent tabindex=\"0\">\n    //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n    // #child, #parent is programmatically focused. This code will attribute the focus to touch\n    // instead of program. This is a relatively minor edge-case that can be worked around by using\n    // focusVia(parent, 'program') to focus #parent.\n    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);\n  }\n  /**\r\n   * Sets the focus classes on the element based on the given focus origin.\r\n   * @param element The element to update the classes on.\r\n   * @param origin The focus origin.\r\n   */\n  _setClasses(element, origin) {\n    element.classList.toggle('cdk-focused', !!origin);\n    element.classList.toggle('cdk-touch-focused', origin === 'touch');\n    element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n    element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n    element.classList.toggle('cdk-program-focused', origin === 'program');\n  }\n  /**\r\n   * Updates the focus origin. If we're using immediate detection mode, we schedule an async\r\n   * function to clear the origin at the end of a timeout. The duration of the timeout depends on\r\n   * the origin being set.\r\n   * @param origin The origin to set.\r\n   * @param isFromInteraction Whether we are setting the origin from an interaction event.\r\n   */\n  _setOrigin(origin, isFromInteraction = false) {\n    this._ngZone.runOutsideAngular(() => {\n      this._origin = origin;\n      this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n      // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n      // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n      // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n      // a touch event because when a touch event is fired, the associated focus event isn't yet in\n      // the event queue. Before doing so, clear any pending timeouts.\n      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n        clearTimeout(this._originTimeoutId);\n        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n        this._originTimeoutId = setTimeout(() => this._origin = null, ms);\n      }\n    });\n  }\n  /**\r\n   * Handles focus events on a registered element.\r\n   * @param event The focus event.\r\n   * @param element The monitored element.\r\n   */\n  _onFocus(event, element) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    const elementInfo = this._elementInfo.get(element);\n    const focusEventTarget = _getEventTarget(event);\n    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {\n      return;\n    }\n    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n  }\n  /**\r\n   * Handles blur events on a registered element.\r\n   * @param event The blur event.\r\n   * @param element The monitored element.\r\n   */\n  _onBlur(event, element) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    const elementInfo = this._elementInfo.get(element);\n    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {\n      return;\n    }\n    this._setClasses(element);\n    this._emitOrigin(elementInfo, null);\n  }\n  _emitOrigin(info, origin) {\n    if (info.subject.observers.length) {\n      this._ngZone.run(() => info.subject.next(origin));\n    }\n  }\n  _registerGlobalListeners(elementInfo) {\n    if (!this._platform.isBrowser) {\n      return;\n    }\n    const rootNode = elementInfo.rootNode;\n    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n    if (!rootNodeFocusListeners) {\n      this._ngZone.runOutsideAngular(() => {\n        rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n      });\n    }\n    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n    // Register global listeners when first element is monitored.\n    if (++this._monitoredElementCount === 1) {\n      // Note: we listen to events in the capture phase so we\n      // can detect them even if the user stops propagation.\n      this._ngZone.runOutsideAngular(() => {\n        const window = this._getWindow();\n        window.addEventListener('focus', this._windowFocusListener);\n      });\n      // The InputModalityDetector is also just a collection of global listeners.\n      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe(modality => {\n        this._setOrigin(modality, true /* isFromInteraction */);\n      });\n    }\n  }\n  _removeGlobalListeners(elementInfo) {\n    const rootNode = elementInfo.rootNode;\n    if (this._rootNodeFocusListenerCount.has(rootNode)) {\n      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n      if (rootNodeFocusListeners > 1) {\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n      } else {\n        rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        this._rootNodeFocusListenerCount.delete(rootNode);\n      }\n    }\n    // Unregister global listeners when last element is unmonitored.\n    if (! --this._monitoredElementCount) {\n      const window = this._getWindow();\n      window.removeEventListener('focus', this._windowFocusListener);\n      // Equivalently, stop our InputModalityDetector subscription.\n      this._stopInputModalityDetector.next();\n      // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n      clearTimeout(this._windowFocusTimeoutId);\n      clearTimeout(this._originTimeoutId);\n    }\n  }\n  /** Updates all the state on an element once its focus origin has changed. */\n  _originChanged(element, origin, elementInfo) {\n    this._setClasses(element, origin);\n    this._emitOrigin(elementInfo, origin);\n    this._lastFocusOrigin = origin;\n  }\n  /**\r\n   * Collects the `MonitoredElementInfo` of a particular element and\r\n   * all of its ancestors that have enabled `checkChildren`.\r\n   * @param element Element from which to start the search.\r\n   */\n  _getClosestElementsInfo(element) {\n    const results = [];\n    this._elementInfo.forEach((info, currentElement) => {\n      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {\n        results.push([currentElement, info]);\n      }\n    });\n    return results;\n  }\n  /**\r\n   * Returns whether an interaction is likely to have come from the user clicking the `label` of\r\n   * an `input` or `textarea` in order to focus it.\r\n   * @param focusEventTarget Target currently receiving focus.\r\n   */\n  _isLastInteractionFromInputLabel(focusEventTarget) {\n    const {\n      _mostRecentTarget: mostRecentTarget,\n      mostRecentModality\n    } = this._inputModalityDetector;\n    // If the last interaction used the mouse on an element contained by one of the labels\n    // of an `input`/`textarea` that is currently focused, it is very likely that the\n    // user redirected focus using the label.\n    if (mostRecentModality !== 'mouse' || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA' || focusEventTarget.disabled) {\n      return false;\n    }\n    const labels = focusEventTarget.labels;\n    if (labels) {\n      for (let i = 0; i < labels.length; i++) {\n        if (labels[i].contains(mostRecentTarget)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  static ɵfac = function FocusMonitor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || FocusMonitor)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusMonitor,\n    factory: FocusMonitor.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FocusMonitor, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\nclass CdkMonitorFocus {\n  _elementRef = inject(ElementRef);\n  _focusMonitor = inject(FocusMonitor);\n  _monitorSubscription;\n  _focusOrigin = null;\n  cdkFocusChange = new EventEmitter();\n  constructor() {}\n  get focusOrigin() {\n    return this._focusOrigin;\n  }\n  ngAfterViewInit() {\n    const element = this._elementRef.nativeElement;\n    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus')).subscribe(origin => {\n      this._focusOrigin = origin;\n      this.cdkFocusChange.emit(origin);\n    });\n  }\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    if (this._monitorSubscription) {\n      this._monitorSubscription.unsubscribe();\n    }\n  }\n  static ɵfac = function CdkMonitorFocus_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || CdkMonitorFocus)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMonitorFocus,\n    selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]],\n    outputs: {\n      cdkFocusChange: \"cdkFocusChange\"\n    },\n    exportAs: [\"cdkMonitorFocus\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMonitorFocus, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n      exportAs: 'cdkMonitorFocus'\n    }]\n  }], () => [], {\n    cdkFocusChange: [{\n      type: Output\n    }]\n  });\n})();\nexport { CdkMonitorFocus as C, FocusMonitor as F, InputModalityDetector as I, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS as a, INPUT_MODALITY_DETECTOR_OPTIONS as b, FocusMonitorDetectionMode as c, FOCUS_MONITOR_DEFAULT_OPTIONS as d };","map":{"version":3,"names":["i0","InjectionToken","inject","NgZone","DOCUMENT","RendererFactory2","Injectable","ElementRef","EventEmitter","Directive","Output","BehaviorSubject","Subject","of","skip","distinctUntilChanged","takeUntil","i","isFakeMousedownFromScreenReader","a","isFakeTouchstartFromScreenReader","d","ALT","C","CONTROL","M","MAC_META","e","META","f","SHIFT","_","_getEventTarget","_getShadowRoot","P","Platform","n","normalizePassiveListenerOptions","coerceElement","INPUT_MODALITY_DETECTOR_OPTIONS","INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS","ignoreKeys","TOUCH_BUFFER_MS","modalityEventListenerOptions","passive","capture","InputModalityDetector","_platform","_listenerCleanups","modalityDetected","modalityChanged","mostRecentModality","_modality","value","_mostRecentTarget","_options","_lastTouchMs","_onKeydown","event","some","keyCode","next","_onMousedown","Date","now","_onTouchstart","constructor","ngZone","document","options","optional","pipe","isBrowser","renderer","createRenderer","runOutsideAngular","listen","ngOnDestroy","complete","forEach","cleanup","ɵfac","InputModalityDetector_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","FocusMonitorDetectionMode","FOCUS_MONITOR_DEFAULT_OPTIONS","captureEventListenerOptions","FocusMonitor","_ngZone","_inputModalityDetector","_origin","_lastFocusOrigin","_windowFocused","_windowFocusTimeoutId","_originTimeoutId","_originFromTouchInteraction","_elementInfo","Map","_monitoredElementCount","_rootNodeFocusListenerCount","_detectionMode","_windowFocusListener","setTimeout","_document","_stopInputModalityDetector","detectionMode","IMMEDIATE","_rootNodeFocusAndBlurListener","target","element","parentElement","_onFocus","_onBlur","monitor","checkChildren","nativeElement","nodeType","rootNode","cachedInfo","get","subject","info","set","_registerGlobalListeners","stopMonitoring","elementInfo","_setClasses","delete","_removeGlobalListeners","focusVia","origin","focusedElement","activeElement","_getClosestElementsInfo","currentElement","_originChanged","_setOrigin","focus","_info","_getWindow","defaultView","window","_getFocusOrigin","focusEventTarget","_shouldBeAttributedToTouch","_isLastInteractionFromInputLabel","EVENTUAL","contains","classList","toggle","isFromInteraction","clearTimeout","ms","relatedTarget","Node","_emitOrigin","observers","length","run","rootNodeFocusListeners","addEventListener","subscribe","modality","has","removeEventListener","results","push","mostRecentTarget","nodeName","disabled","labels","FocusMonitor_Factory","CdkMonitorFocus","_elementRef","_focusMonitor","_monitorSubscription","_focusOrigin","cdkFocusChange","focusOrigin","ngAfterViewInit","hasAttribute","emit","unsubscribe","CdkMonitorFocus_Factory","ɵdir","ɵɵdefineDirective","selectors","outputs","exportAs","selector","F","I","b","c"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/cdk/fesm2022/focus-monitor-DUe99AIS.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\r\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\r\nimport { BehaviorSubject, Subject, of } from 'rxjs';\r\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\r\nimport { i as isFakeMousedownFromScreenReader, a as isFakeTouchstartFromScreenReader } from './fake-event-detection-DWOdFTFz.mjs';\r\nimport { d as ALT, C as CONTROL, M as MAC_META, e as META, f as SHIFT } from './keycodes-CpHkExLC.mjs';\r\nimport { _ as _getEventTarget, a as _getShadowRoot } from './shadow-dom-B0oHn41l.mjs';\r\nimport { P as Platform } from './platform-DNDzkVcI.mjs';\r\nimport { n as normalizePassiveListenerOptions } from './passive-listeners-esHZRgIN.mjs';\r\nimport { a as coerceElement } from './element-x4z00URv.mjs';\r\n\r\n/**\r\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\r\n * options.\r\n */\r\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\r\n/**\r\n * Default options for the InputModalityDetector.\r\n *\r\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\r\n * keyboard input modality) for two reasons:\r\n *\r\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\r\n *    in new tab', and are thus less representative of actual keyboard interaction.\r\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\r\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\r\n *    these keys so as to not update the input modality.\r\n *\r\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\r\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\r\n * distinguish between the two.\r\n */\r\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\r\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\r\n};\r\n/**\r\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\r\n * event to be attributed as mouse and not touch.\r\n *\r\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n * that a value of around 650ms seems appropriate.\r\n */\r\nconst TOUCH_BUFFER_MS = 650;\r\n/**\r\n * Event listener options that enable capturing and also mark the listener as passive if the browser\r\n * supports it.\r\n */\r\nconst modalityEventListenerOptions = {\r\n    passive: true,\r\n    capture: true,\r\n};\r\n/**\r\n * Service that detects the user's input modality.\r\n *\r\n * This service does not update the input modality when a user navigates with a screen reader\r\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\r\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\r\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\r\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\r\n * input interaction.\r\n *\r\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\r\n * update the input modality to keyboard, but in general this service's behavior is largely\r\n * undefined.\r\n */\r\nclass InputModalityDetector {\r\n    _platform = inject(Platform);\r\n    _listenerCleanups;\r\n    /** Emits whenever an input modality is detected. */\r\n    modalityDetected;\r\n    /** Emits when the input modality changes. */\r\n    modalityChanged;\r\n    /** The most recently detected input modality. */\r\n    get mostRecentModality() {\r\n        return this._modality.value;\r\n    }\r\n    /**\r\n     * The most recently detected input modality event target. Is null if no input modality has been\r\n     * detected or if the associated event target is null for some unknown reason.\r\n     */\r\n    _mostRecentTarget = null;\r\n    /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\r\n    _modality = new BehaviorSubject(null);\r\n    /** Options for this InputModalityDetector. */\r\n    _options;\r\n    /**\r\n     * The timestamp of the last touch input modality. Used to determine whether mousedown events\r\n     * should be attributed to mouse or touch.\r\n     */\r\n    _lastTouchMs = 0;\r\n    /**\r\n     * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\r\n     * bound.\r\n     */\r\n    _onKeydown = (event) => {\r\n        // If this is one of the keys we should ignore, then ignore it and don't update the input\r\n        // modality to keyboard.\r\n        if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\r\n            return;\r\n        }\r\n        this._modality.next('keyboard');\r\n        this._mostRecentTarget = _getEventTarget(event);\r\n    };\r\n    /**\r\n     * Handles mousedown events. Must be an arrow function in order to preserve the context when it\r\n     * gets bound.\r\n     */\r\n    _onMousedown = (event) => {\r\n        // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\r\n        // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\r\n        // after the previous touch event.\r\n        if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\r\n            return;\r\n        }\r\n        // Fake mousedown events are fired by some screen readers when controls are activated by the\r\n        // screen reader. Attribute them to keyboard input modality.\r\n        this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\r\n        this._mostRecentTarget = _getEventTarget(event);\r\n    };\r\n    /**\r\n     * Handles touchstart events. Must be an arrow function in order to preserve the context when it\r\n     * gets bound.\r\n     */\r\n    _onTouchstart = (event) => {\r\n        // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\r\n        // events are fired. Again, attribute to keyboard input modality.\r\n        if (isFakeTouchstartFromScreenReader(event)) {\r\n            this._modality.next('keyboard');\r\n            return;\r\n        }\r\n        // Store the timestamp of this touch event, as it's used to distinguish between mouse events\r\n        // triggered via mouse vs touch.\r\n        this._lastTouchMs = Date.now();\r\n        this._modality.next('touch');\r\n        this._mostRecentTarget = _getEventTarget(event);\r\n    };\r\n    constructor() {\r\n        const ngZone = inject(NgZone);\r\n        const document = inject(DOCUMENT);\r\n        const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, { optional: true });\r\n        this._options = {\r\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\r\n            ...options,\r\n        };\r\n        // Skip the first emission as it's null.\r\n        this.modalityDetected = this._modality.pipe(skip(1));\r\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\r\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\r\n        // modality to detect.\r\n        if (this._platform.isBrowser) {\r\n            const renderer = inject(RendererFactory2).createRenderer(null, null);\r\n            this._listenerCleanups = ngZone.runOutsideAngular(() => {\r\n                return [\r\n                    renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions),\r\n                    renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions),\r\n                    renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions),\r\n                ];\r\n            });\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._modality.complete();\r\n        this._listenerCleanups?.forEach(cleanup => cleanup());\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: InputModalityDetector, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: InputModalityDetector, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: InputModalityDetector, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [] });\r\n\r\n/** Detection mode used for attributing the origin of a focus event. */\r\nvar FocusMonitorDetectionMode;\r\n(function (FocusMonitorDetectionMode) {\r\n    /**\r\n     * Any mousedown, keydown, or touchstart event that happened in the previous\r\n     * tick or the current tick will be used to assign a focus event's origin (to\r\n     * either mouse, keyboard, or touch). This is the default option.\r\n     */\r\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\r\n    /**\r\n     * A focus event's origin is always attributed to the last corresponding\r\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\r\n     */\r\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\r\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\r\n/** InjectionToken for FocusMonitorOptions. */\r\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\r\n/**\r\n * Event listener options that enable capturing and also\r\n * mark the listener as passive if the browser supports it.\r\n */\r\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\r\n    passive: true,\r\n    capture: true,\r\n});\r\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\r\nclass FocusMonitor {\r\n    _ngZone = inject(NgZone);\r\n    _platform = inject(Platform);\r\n    _inputModalityDetector = inject(InputModalityDetector);\r\n    /** The focus origin that the next focus event is a result of. */\r\n    _origin = null;\r\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\r\n    _lastFocusOrigin;\r\n    /** Whether the window has just been focused. */\r\n    _windowFocused = false;\r\n    /** The timeout id of the window focus timeout. */\r\n    _windowFocusTimeoutId;\r\n    /** The timeout id of the origin clearing timeout. */\r\n    _originTimeoutId;\r\n    /**\r\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\r\n     * focus events to touch interactions requires special logic.\r\n     */\r\n    _originFromTouchInteraction = false;\r\n    /** Map of elements being monitored to their info. */\r\n    _elementInfo = new Map();\r\n    /** The number of elements currently being monitored. */\r\n    _monitoredElementCount = 0;\r\n    /**\r\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\r\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\r\n     * handlers differently from the rest of the events, because the browser won't emit events\r\n     * to the document when focus moves inside of a shadow root.\r\n     */\r\n    _rootNodeFocusListenerCount = new Map();\r\n    /**\r\n     * The specified detection mode, used for attributing the origin of a focus\r\n     * event.\r\n     */\r\n    _detectionMode;\r\n    /**\r\n     * Event listener for `focus` events on the window.\r\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n     */\r\n    _windowFocusListener = () => {\r\n        // Make a note of when the window regains focus, so we can\r\n        // restore the origin info for the focused element.\r\n        this._windowFocused = true;\r\n        this._windowFocusTimeoutId = setTimeout(() => (this._windowFocused = false));\r\n    };\r\n    /** Used to reference correct document/window */\r\n    _document = inject(DOCUMENT);\r\n    /** Subject for stopping our InputModalityDetector subscription. */\r\n    _stopInputModalityDetector = new Subject();\r\n    constructor() {\r\n        const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\r\n            optional: true,\r\n        });\r\n        this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\r\n    }\r\n    /**\r\n     * Event listener for `focus` and 'blur' events on the document.\r\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n     */\r\n    _rootNodeFocusAndBlurListener = (event) => {\r\n        const target = _getEventTarget(event);\r\n        // We need to walk up the ancestor chain in order to support `checkChildren`.\r\n        for (let element = target; element; element = element.parentElement) {\r\n            if (event.type === 'focus') {\r\n                this._onFocus(event, element);\r\n            }\r\n            else {\r\n                this._onBlur(event, element);\r\n            }\r\n        }\r\n    };\r\n    monitor(element, checkChildren = false) {\r\n        const nativeElement = coerceElement(element);\r\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\r\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\r\n            // Note: we don't want the observable to emit at all so we don't pass any parameters.\r\n            return of();\r\n        }\r\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\r\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\r\n        // to the `document`, if focus is moving within the same shadow root.\r\n        const rootNode = _getShadowRoot(nativeElement) || this._document;\r\n        const cachedInfo = this._elementInfo.get(nativeElement);\r\n        // Check if we're already monitoring this element.\r\n        if (cachedInfo) {\r\n            if (checkChildren) {\r\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\r\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\r\n                // robust solution.\r\n                cachedInfo.checkChildren = true;\r\n            }\r\n            return cachedInfo.subject;\r\n        }\r\n        // Create monitored element info.\r\n        const info = {\r\n            checkChildren: checkChildren,\r\n            subject: new Subject(),\r\n            rootNode,\r\n        };\r\n        this._elementInfo.set(nativeElement, info);\r\n        this._registerGlobalListeners(info);\r\n        return info.subject;\r\n    }\r\n    stopMonitoring(element) {\r\n        const nativeElement = coerceElement(element);\r\n        const elementInfo = this._elementInfo.get(nativeElement);\r\n        if (elementInfo) {\r\n            elementInfo.subject.complete();\r\n            this._setClasses(nativeElement);\r\n            this._elementInfo.delete(nativeElement);\r\n            this._removeGlobalListeners(elementInfo);\r\n        }\r\n    }\r\n    focusVia(element, origin, options) {\r\n        const nativeElement = coerceElement(element);\r\n        const focusedElement = this._document.activeElement;\r\n        // If the element is focused already, calling `focus` again won't trigger the event listener\r\n        // which means that the focus classes won't be updated. If that's the case, update the classes\r\n        // directly without waiting for an event.\r\n        if (nativeElement === focusedElement) {\r\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\r\n        }\r\n        else {\r\n            this._setOrigin(origin);\r\n            // `focus` isn't available on the server\r\n            if (typeof nativeElement.focus === 'function') {\r\n                nativeElement.focus(options);\r\n            }\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    _getFocusOrigin(focusEventTarget) {\r\n        if (this._origin) {\r\n            // If the origin was realized via a touch interaction, we need to perform additional checks\r\n            // to determine whether the focus origin should be attributed to touch or program.\r\n            if (this._originFromTouchInteraction) {\r\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\r\n            }\r\n            else {\r\n                return this._origin;\r\n            }\r\n        }\r\n        // If the window has just regained focus, we can restore the most recent origin from before the\r\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\r\n        // focus. This typically means one of two things happened:\r\n        //\r\n        // 1) The element was programmatically focused, or\r\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\r\n        //    events).\r\n        //\r\n        // Because we can't distinguish between these two cases, we default to setting `program`.\r\n        if (this._windowFocused && this._lastFocusOrigin) {\r\n            return this._lastFocusOrigin;\r\n        }\r\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\r\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\r\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\r\n        // special case, because it's very common for checkboxes and radio buttons.\r\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\r\n            return 'mouse';\r\n        }\r\n        return 'program';\r\n    }\r\n    /**\r\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\r\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\r\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\r\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\r\n     * subsequent programmatic focus call triggered by the touch interaction.\r\n     * @param focusEventTarget The target of the focus event under examination.\r\n     */\r\n    _shouldBeAttributedToTouch(focusEventTarget) {\r\n        // Please note that this check is not perfect. Consider the following edge case:\r\n        //\r\n        // <div #parent tabindex=\"0\">\r\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\r\n        // </div>\r\n        //\r\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\r\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\r\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\r\n        // focusVia(parent, 'program') to focus #parent.\r\n        return (this._detectionMode === FocusMonitorDetectionMode.EVENTUAL ||\r\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\r\n    }\r\n    /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @param element The element to update the classes on.\r\n     * @param origin The focus origin.\r\n     */\r\n    _setClasses(element, origin) {\r\n        element.classList.toggle('cdk-focused', !!origin);\r\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\r\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\r\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\r\n        element.classList.toggle('cdk-program-focused', origin === 'program');\r\n    }\r\n    /**\r\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\r\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\r\n     * the origin being set.\r\n     * @param origin The origin to set.\r\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\r\n     */\r\n    _setOrigin(origin, isFromInteraction = false) {\r\n        this._ngZone.runOutsideAngular(() => {\r\n            this._origin = origin;\r\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\r\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\r\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\r\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\r\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\r\n            // the event queue. Before doing so, clear any pending timeouts.\r\n            if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\r\n                clearTimeout(this._originTimeoutId);\r\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\r\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Handles focus events on a registered element.\r\n     * @param event The focus event.\r\n     * @param element The monitored element.\r\n     */\r\n    _onFocus(event, element) {\r\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n        // focus event affecting the monitored element. If we want to use the origin of the first event\r\n        // instead we should check for the cdk-focused class here and return if the element already has\r\n        // it. (This only matters for elements that have includesChildren = true).\r\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\r\n        // monitored element itself.\r\n        const elementInfo = this._elementInfo.get(element);\r\n        const focusEventTarget = _getEventTarget(event);\r\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\r\n            return;\r\n        }\r\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\r\n    }\r\n    /**\r\n     * Handles blur events on a registered element.\r\n     * @param event The blur event.\r\n     * @param element The monitored element.\r\n     */\r\n    _onBlur(event, element) {\r\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\r\n        // order to focus another child of the monitored element.\r\n        const elementInfo = this._elementInfo.get(element);\r\n        if (!elementInfo ||\r\n            (elementInfo.checkChildren &&\r\n                event.relatedTarget instanceof Node &&\r\n                element.contains(event.relatedTarget))) {\r\n            return;\r\n        }\r\n        this._setClasses(element);\r\n        this._emitOrigin(elementInfo, null);\r\n    }\r\n    _emitOrigin(info, origin) {\r\n        if (info.subject.observers.length) {\r\n            this._ngZone.run(() => info.subject.next(origin));\r\n        }\r\n    }\r\n    _registerGlobalListeners(elementInfo) {\r\n        if (!this._platform.isBrowser) {\r\n            return;\r\n        }\r\n        const rootNode = elementInfo.rootNode;\r\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\r\n        if (!rootNodeFocusListeners) {\r\n            this._ngZone.runOutsideAngular(() => {\r\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\r\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\r\n            });\r\n        }\r\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\r\n        // Register global listeners when first element is monitored.\r\n        if (++this._monitoredElementCount === 1) {\r\n            // Note: we listen to events in the capture phase so we\r\n            // can detect them even if the user stops propagation.\r\n            this._ngZone.runOutsideAngular(() => {\r\n                const window = this._getWindow();\r\n                window.addEventListener('focus', this._windowFocusListener);\r\n            });\r\n            // The InputModalityDetector is also just a collection of global listeners.\r\n            this._inputModalityDetector.modalityDetected\r\n                .pipe(takeUntil(this._stopInputModalityDetector))\r\n                .subscribe(modality => {\r\n                this._setOrigin(modality, true /* isFromInteraction */);\r\n            });\r\n        }\r\n    }\r\n    _removeGlobalListeners(elementInfo) {\r\n        const rootNode = elementInfo.rootNode;\r\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\r\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\r\n            if (rootNodeFocusListeners > 1) {\r\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\r\n            }\r\n            else {\r\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\r\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\r\n                this._rootNodeFocusListenerCount.delete(rootNode);\r\n            }\r\n        }\r\n        // Unregister global listeners when last element is unmonitored.\r\n        if (!--this._monitoredElementCount) {\r\n            const window = this._getWindow();\r\n            window.removeEventListener('focus', this._windowFocusListener);\r\n            // Equivalently, stop our InputModalityDetector subscription.\r\n            this._stopInputModalityDetector.next();\r\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\r\n            clearTimeout(this._windowFocusTimeoutId);\r\n            clearTimeout(this._originTimeoutId);\r\n        }\r\n    }\r\n    /** Updates all the state on an element once its focus origin has changed. */\r\n    _originChanged(element, origin, elementInfo) {\r\n        this._setClasses(element, origin);\r\n        this._emitOrigin(elementInfo, origin);\r\n        this._lastFocusOrigin = origin;\r\n    }\r\n    /**\r\n     * Collects the `MonitoredElementInfo` of a particular element and\r\n     * all of its ancestors that have enabled `checkChildren`.\r\n     * @param element Element from which to start the search.\r\n     */\r\n    _getClosestElementsInfo(element) {\r\n        const results = [];\r\n        this._elementInfo.forEach((info, currentElement) => {\r\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\r\n                results.push([currentElement, info]);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    /**\r\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\r\n     * an `input` or `textarea` in order to focus it.\r\n     * @param focusEventTarget Target currently receiving focus.\r\n     */\r\n    _isLastInteractionFromInputLabel(focusEventTarget) {\r\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\r\n        // If the last interaction used the mouse on an element contained by one of the labels\r\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\r\n        // user redirected focus using the label.\r\n        if (mostRecentModality !== 'mouse' ||\r\n            !mostRecentTarget ||\r\n            mostRecentTarget === focusEventTarget ||\r\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\r\n            focusEventTarget.disabled) {\r\n            return false;\r\n        }\r\n        const labels = focusEventTarget.labels;\r\n        if (labels) {\r\n            for (let i = 0; i < labels.length; i++) {\r\n                if (labels[i].contains(mostRecentTarget)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusMonitor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusMonitor, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusMonitor, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [] });\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\r\nclass CdkMonitorFocus {\r\n    _elementRef = inject(ElementRef);\r\n    _focusMonitor = inject(FocusMonitor);\r\n    _monitorSubscription;\r\n    _focusOrigin = null;\r\n    cdkFocusChange = new EventEmitter();\r\n    constructor() { }\r\n    get focusOrigin() {\r\n        return this._focusOrigin;\r\n    }\r\n    ngAfterViewInit() {\r\n        const element = this._elementRef.nativeElement;\r\n        this._monitorSubscription = this._focusMonitor\r\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\r\n            .subscribe(origin => {\r\n            this._focusOrigin = origin;\r\n            this.cdkFocusChange.emit(origin);\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n        if (this._monitorSubscription) {\r\n            this._monitorSubscription.unsubscribe();\r\n        }\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: CdkMonitorFocus, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.0.0\", type: CdkMonitorFocus, isStandalone: true, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: CdkMonitorFocus, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\r\n                    exportAs: 'cdkMonitorFocus',\r\n                }]\r\n        }], ctorParameters: () => [], propDecorators: { cdkFocusChange: [{\r\n                type: Output\r\n            }] } });\r\n\r\nexport { CdkMonitorFocus as C, FocusMonitor as F, InputModalityDetector as I, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS as a, INPUT_MODALITY_DETECTOR_OPTIONS as b, FocusMonitorDetectionMode as c, FOCUS_MONITOR_DEFAULT_OPTIONS as d };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}