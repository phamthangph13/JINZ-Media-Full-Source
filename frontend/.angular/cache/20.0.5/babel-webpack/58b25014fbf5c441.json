{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { inject, ErrorHandler, DestroyRef, RuntimeError, formatRuntimeError, assertNotInReactiveContext, assertInInjectionContext, Injector, ViewContext, ChangeDetectionScheduler, EffectScheduler, setInjectorProfilerContext, emitEffectCreatedEvent, EFFECTS, NodeInjectorDestroyRef, FLAGS, markAncestorsForTraversal, noop, setIsRefreshingViews, signalAsReadonlyFn, PendingTasks, signal } from './root_effect_scheduler.mjs';\nimport { setActiveConsumer, createComputed, SIGNAL, consumerDestroy, REACTIVE_NODE, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from './signal.mjs';\nimport { untracked as untracked$1, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn } from './untracked.mjs';\n\n/**\r\n * An `OutputEmitterRef` is created by the `output()` function and can be\r\n * used to emit values to consumers of your directive or component.\r\n *\r\n * Consumers of your directive/component can bind to the output and\r\n * subscribe to changes via the bound event syntax. For example:\r\n *\r\n * ```html\r\n * <my-comp (valueChange)=\"processNewValue($event)\" />\r\n * ```\r\n *\r\n * @publicAPI\r\n */\nclass OutputEmitterRef {\n  destroyed = false;\n  listeners = null;\n  errorHandler = inject(ErrorHandler, {\n    optional: true\n  });\n  /** @internal */\n  destroyRef = inject(DestroyRef);\n  constructor() {\n    // Clean-up all listeners and mark as destroyed upon destroy.\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n      this.listeners = null;\n    });\n  }\n  subscribe(callback) {\n    if (this.destroyed) {\n      throw new RuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    (this.listeners ??= []).push(callback);\n    return {\n      unsubscribe: () => {\n        const idx = this.listeners?.indexOf(callback);\n        if (idx !== undefined && idx !== -1) {\n          this.listeners?.splice(idx, 1);\n        }\n      }\n    };\n  }\n  /** Emits a new value to the output. */\n  emit(value) {\n    if (this.destroyed) {\n      console.warn(formatRuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected emit for destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.'));\n      return;\n    }\n    if (this.listeners === null) {\n      return;\n    }\n    const previousConsumer = setActiveConsumer(null);\n    try {\n      for (const listenerFn of this.listeners) {\n        try {\n          listenerFn(value);\n        } catch (err) {\n          this.errorHandler?.handleError(err);\n        }\n      }\n    } finally {\n      setActiveConsumer(previousConsumer);\n    }\n  }\n}\n/** Gets the owning `DestroyRef` for the given output. */\nfunction getOutputDestroyRef(ref) {\n  return ref.destroyRef;\n}\n\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\nfunction untracked(nonReactiveReadsFn) {\n  return untracked$1(nonReactiveReadsFn);\n}\n\n/**\r\n * Create a computed `Signal` which derives a reactive value from an expression.\r\n */\nfunction computed(computation, options) {\n  const getter = createComputed(computation, options?.equal);\n  if (ngDevMode) {\n    getter.toString = () => `[Computed: ${getter()}]`;\n    getter[SIGNAL].debugName = options?.debugName;\n  }\n  return getter;\n}\nclass EffectRefImpl {\n  [SIGNAL];\n  constructor(node) {\n    this[SIGNAL] = node;\n  }\n  destroy() {\n    this[SIGNAL].destroy();\n  }\n}\n/**\r\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\r\n * changes.\r\n *\r\n * Angular has two different kinds of effect: component effects and root effects. Component effects\r\n * are created when `effect()` is called from a component, directive, or within a service of a\r\n * component/directive. Root effects are created when `effect()` is called from outside the\r\n * component tree, such as in a root service.\r\n *\r\n * The two effect types differ in their timing. Component effects run as a component lifecycle\r\n * event during Angular's synchronization (change detection) process, and can safely read input\r\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\r\n * and have no connection to the component tree or change detection.\r\n *\r\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\r\n *\r\n * @publicApi 20.0\r\n */\nfunction effect(effectFn, options) {\n  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  let node;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    // This effect was created in the context of a view, and will be associated with the view.\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      // The effect is being created in the same view as the `DestroyRef` references, so it will be\n      // automatically destroyed without the need for an explicit `DestroyRef` registration.\n      destroyRef = null;\n    }\n  } else {\n    // This effect was created outside the context of a view, and will be scheduled independently.\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n  if (destroyRef !== null) {\n    // If we need to register for cleanup, do that here.\n    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\n  }\n  const effectRef = new EffectRefImpl(node);\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n  return effectRef;\n}\nconst BASE_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  dirty: true,\n  hasRun: false,\n  cleanupFns: undefined,\n  zone: null,\n  kind: 'effect',\n  onDestroyFn: noop,\n  run() {\n    this.dirty = false;\n    if (ngDevMode && isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    if (this.hasRun && !consumerPollProducersForChange(this)) {\n      return;\n    }\n    this.hasRun = true;\n    const registerCleanupFn = cleanupFn => (this.cleanupFns ??= []).push(cleanupFn);\n    const prevNode = consumerBeforeComputation(this);\n    // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\n    // cause CD to reach the component in question.\n    const prevRefreshingViews = setIsRefreshingViews(false);\n    try {\n      this.maybeCleanup();\n      this.fn(registerCleanupFn);\n    } finally {\n      setIsRefreshingViews(prevRefreshingViews);\n      consumerAfterComputation(this, prevNode);\n    }\n  },\n  maybeCleanup() {\n    if (!this.cleanupFns?.length) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      // Attempt to run the cleanup functions. Regardless of failure or success, we consider\n      // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\n      // from the cleanup function will still crash the current run of the effect.\n      while (this.cleanupFns.length) {\n        this.cleanupFns.pop()();\n      }\n    } finally {\n      this.cleanupFns = [];\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}))();\nconst ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...BASE_EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.scheduler.schedule(this);\n    this.notifier.notify(12 /* NotificationSource.RootEffect */);\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.maybeCleanup();\n    this.scheduler.remove(this);\n  }\n}))();\nconst VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...BASE_EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.view[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\n    markAncestorsForTraversal(this.view);\n    this.notifier.notify(13 /* NotificationSource.ViewEffect */);\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.maybeCleanup();\n    this.view[EFFECTS]?.delete(this);\n  }\n}))();\nfunction createViewEffect(view, notifier, fn) {\n  const node = Object.create(VIEW_EFFECT_NODE);\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = fn;\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n  node.consumerMarkedDirty(node);\n  return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n  const node = Object.create(ROOT_EFFECT_NODE);\n  node.fn = fn;\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(12 /* NotificationSource.RootEffect */);\n  return node;\n}\nconst identityFn = v => v;\nfunction linkedSignal(optionsOrComputation, options) {\n  if (typeof optionsOrComputation === 'function') {\n    const getter = createLinkedSignal(optionsOrComputation, identityFn, options?.equal);\n    return upgradeLinkedSignalGetter(getter);\n  } else {\n    const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\n    return upgradeLinkedSignalGetter(getter);\n  }\n}\nfunction upgradeLinkedSignalGetter(getter) {\n  if (ngDevMode) {\n    getter.toString = () => `[LinkedSignal: ${getter()}]`;\n  }\n  const node = getter[SIGNAL];\n  const upgradedGetter = getter;\n  upgradedGetter.set = newValue => linkedSignalSetFn(node, newValue);\n  upgradedGetter.update = updateFn => linkedSignalUpdateFn(node, updateFn);\n  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\n  return upgradedGetter;\n}\n\n/**\r\n * Whether a `Resource.value()` should throw an error when the resource is in the error state.\r\n *\r\n * This internal flag is being used to gradually roll out this behavior.\r\n */\nconst RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;\nfunction resource(options) {\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(resource);\n  }\n  const oldNameForParams = options.request;\n  const params = options.params ?? oldNameForParams ?? (() => null);\n  return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.injector ?? inject(Injector), RESOURCE_VALUE_THROWS_ERRORS_DEFAULT);\n}\n/**\r\n * Base class which implements `.value` as a `WritableSignal` by delegating `.set` and `.update`.\r\n */\nclass BaseWritableResource {\n  value;\n  constructor(value) {\n    this.value = value;\n    this.value.set = this.set.bind(this);\n    this.value.update = this.update.bind(this);\n    this.value.asReadonly = signalAsReadonlyFn;\n  }\n  isError = computed(() => this.status() === 'error');\n  update(updateFn) {\n    this.set(updateFn(untracked(this.value)));\n  }\n  isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading');\n  hasValue() {\n    // Note: we specifically read `isError()` instead of `status()` here to avoid triggering\n    // reactive consumers which read `hasValue()`. This way, if `hasValue()` is used inside of an\n    // effect, it doesn't cause the effect to rerun on every status change.\n    if (this.isError()) {\n      return false;\n    }\n    return this.value() !== undefined;\n  }\n  asReadonly() {\n    return this;\n  }\n}\n/**\r\n * Implementation for `resource()` which uses a `linkedSignal` to manage the resource's state.\r\n */\nclass ResourceImpl extends BaseWritableResource {\n  loaderFn;\n  equal;\n  pendingTasks;\n  /**\r\n   * The current state of the resource. Status, value, and error are derived from this.\r\n   */\n  state;\n  /**\r\n   * Combines the current request with a reload counter which allows the resource to be reloaded on\r\n   * imperative command.\r\n   */\n  extRequest;\n  effectRef;\n  pendingController;\n  resolvePendingTask = undefined;\n  destroyed = false;\n  unregisterOnDestroy;\n  constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {\n    super(\n    // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\n    // `WritableSignal` that delegates to `ResourceImpl.set`.\n    computed(() => {\n      const streamValue = this.state().stream?.();\n      if (!streamValue) {\n        return defaultValue;\n      }\n      // Prevents `hasValue()` from throwing an error when a reload happened in the error state\n      if (this.state().status === 'loading' && this.error()) {\n        return defaultValue;\n      }\n      if (!isResolved(streamValue)) {\n        if (throwErrorsFromValue) {\n          throw new ResourceValueError(this.error());\n        } else {\n          return defaultValue;\n        }\n      }\n      return streamValue.value;\n    }, {\n      equal\n    }));\n    this.loaderFn = loaderFn;\n    this.equal = equal;\n    // Extend `request()` to include a writable reload signal.\n    this.extRequest = linkedSignal({\n      source: request,\n      computation: request => ({\n        request,\n        reload: 0\n      })\n    });\n    // The main resource state is managed in a `linkedSignal`, which allows the resource to change\n    // state instantaneously when the request signal changes.\n    this.state = linkedSignal({\n      // Whenever the request changes,\n      source: this.extRequest,\n      // Compute the state of the resource given a change in status.\n      computation: (extRequest, previous) => {\n        const status = extRequest.request === undefined ? 'idle' : 'loading';\n        if (!previous) {\n          return {\n            extRequest,\n            status,\n            previousStatus: 'idle',\n            stream: undefined\n          };\n        } else {\n          return {\n            extRequest,\n            status,\n            previousStatus: projectStatusOfState(previous.value),\n            // If the request hasn't changed, keep the previous stream.\n            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : undefined\n          };\n        }\n      }\n    });\n    this.effectRef = effect(this.loadEffect.bind(this), {\n      injector,\n      manualCleanup: true\n    });\n    this.pendingTasks = injector.get(PendingTasks);\n    // Cancel any pending request when the resource itself is destroyed.\n    this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());\n  }\n  status = computed(() => projectStatusOfState(this.state()));\n  error = computed(() => {\n    const stream = this.state().stream?.();\n    return stream && !isResolved(stream) ? stream.error : undefined;\n  });\n  /**\r\n   * Called either directly via `WritableResource.set` or via `.value.set()`.\r\n   */\n  set(value) {\n    if (this.destroyed) {\n      return;\n    }\n    const error = untracked(this.error);\n    const state = untracked(this.state);\n    if (!error) {\n      const current = untracked(this.value);\n      if (state.status === 'local' && (this.equal ? this.equal(current, value) : current === value)) {\n        return;\n      }\n    }\n    // Enter Local state with the user-defined value.\n    this.state.set({\n      extRequest: state.extRequest,\n      status: 'local',\n      previousStatus: 'local',\n      stream: signal({\n        value\n      })\n    });\n    // We're departing from whatever state the resource was in previously, so cancel any in-progress\n    // loading operations.\n    this.abortInProgressLoad();\n  }\n  reload() {\n    // We don't want to restart in-progress loads.\n    const {\n      status\n    } = untracked(this.state);\n    if (status === 'idle' || status === 'loading') {\n      return false;\n    }\n    // Increment the request reload to trigger the `state` linked signal to switch us to `Reload`\n    this.extRequest.update(({\n      request,\n      reload\n    }) => ({\n      request,\n      reload: reload + 1\n    }));\n    return true;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.unregisterOnDestroy();\n    this.effectRef.destroy();\n    this.abortInProgressLoad();\n    // Destroyed resources enter Idle state.\n    this.state.set({\n      extRequest: {\n        request: undefined,\n        reload: 0\n      },\n      status: 'idle',\n      previousStatus: 'idle',\n      stream: undefined\n    });\n  }\n  loadEffect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const extRequest = _this.extRequest();\n      // Capture the previous status before any state transitions. Note that this is `untracked` since\n      // we do not want the effect to depend on the state of the resource, only on the request.\n      const {\n        status: currentStatus,\n        previousStatus\n      } = untracked(_this.state);\n      if (extRequest.request === undefined) {\n        // Nothing to load (and we should already be in a non-loading state).\n        return;\n      } else if (currentStatus !== 'loading') {\n        // We're not in a loading or reloading state, so this loading request is stale.\n        return;\n      }\n      // Cancel any previous loading attempts.\n      _this.abortInProgressLoad();\n      // Capturing _this_ load's pending task in a local variable is important here. We may attempt to\n      // resolve it twice:\n      //\n      //  1. when the loading function promise resolves/rejects\n      //  2. when cancelling the loading operation\n      //\n      // After the loading operation is cancelled, `this.resolvePendingTask` no longer represents this\n      // particular task, but this `await` may eventually resolve/reject. Thus, when we cancel in\n      // response to (1) below, we need to cancel the locally saved task.\n      let resolvePendingTask = _this.resolvePendingTask = _this.pendingTasks.add();\n      const {\n        signal: abortSignal\n      } = _this.pendingController = new AbortController();\n      try {\n        // The actual loading is run through `untracked` - only the request side of `resource` is\n        // reactive. This avoids any confusion with signals tracking or not tracking depending on\n        // which side of the `await` they are.\n        const stream = yield untracked(() => {\n          return _this.loaderFn({\n            params: extRequest.request,\n            // TODO(alxhub): cleanup after g3 removal of `request` alias.\n            request: extRequest.request,\n            abortSignal,\n            previous: {\n              status: previousStatus\n            }\n          });\n        });\n        // If this request has been aborted, or the current request no longer\n        // matches this load, then we should ignore this resolution.\n        if (abortSignal.aborted || untracked(_this.extRequest) !== extRequest) {\n          return;\n        }\n        _this.state.set({\n          extRequest,\n          status: 'resolved',\n          previousStatus: 'resolved',\n          stream\n        });\n      } catch (err) {\n        if (abortSignal.aborted || untracked(_this.extRequest) !== extRequest) {\n          return;\n        }\n        _this.state.set({\n          extRequest,\n          status: 'resolved',\n          previousStatus: 'error',\n          stream: signal({\n            error: encapsulateResourceError(err)\n          })\n        });\n      } finally {\n        // Resolve the pending task now that the resource has a value.\n        resolvePendingTask?.();\n        resolvePendingTask = undefined;\n      }\n    })();\n  }\n  abortInProgressLoad() {\n    untracked(() => this.pendingController?.abort());\n    this.pendingController = undefined;\n    // Once the load is aborted, we no longer want to block stability on its resolution.\n    this.resolvePendingTask?.();\n    this.resolvePendingTask = undefined;\n  }\n}\n/**\r\n * Wraps an equality function to handle either value being `undefined`.\r\n */\nfunction wrapEqualityFn(equal) {\n  return (a, b) => a === undefined || b === undefined ? a === b : equal(a, b);\n}\nfunction getLoader(options) {\n  if (isStreamingResourceOptions(options)) {\n    return options.stream;\n  }\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (params) {\n      try {\n        return signal({\n          value: yield options.loader(params)\n        });\n      } catch (err) {\n        return signal({\n          error: encapsulateResourceError(err)\n        });\n      }\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nfunction isStreamingResourceOptions(options) {\n  return !!options.stream;\n}\n/**\r\n * Project from a state with `ResourceInternalStatus` to the user-facing `ResourceStatus`\r\n */\nfunction projectStatusOfState(state) {\n  switch (state.status) {\n    case 'loading':\n      return state.extRequest.reload === 0 ? 'loading' : 'reloading';\n    case 'resolved':\n      return isResolved(state.stream()) ? 'resolved' : 'error';\n    default:\n      return state.status;\n  }\n}\nfunction isResolved(state) {\n  return state.error === undefined;\n}\nfunction encapsulateResourceError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  return new ResourceWrappedError(error);\n}\nclass ResourceValueError extends Error {\n  constructor(error) {\n    super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, {\n      cause: error\n    });\n  }\n}\nclass ResourceWrappedError extends Error {\n  constructor(error) {\n    super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), {\n      cause: error\n    });\n  }\n}\nexport { OutputEmitterRef, ResourceImpl, computed, effect, encapsulateResourceError, getOutputDestroyRef, linkedSignal, resource, untracked };","map":{"version":3,"names":["inject","ErrorHandler","DestroyRef","RuntimeError","formatRuntimeError","assertNotInReactiveContext","assertInInjectionContext","Injector","ViewContext","ChangeDetectionScheduler","EffectScheduler","setInjectorProfilerContext","emitEffectCreatedEvent","EFFECTS","NodeInjectorDestroyRef","FLAGS","markAncestorsForTraversal","noop","setIsRefreshingViews","signalAsReadonlyFn","PendingTasks","signal","setActiveConsumer","createComputed","SIGNAL","consumerDestroy","REACTIVE_NODE","isInNotificationPhase","consumerPollProducersForChange","consumerBeforeComputation","consumerAfterComputation","untracked","untracked$1","createLinkedSignal","linkedSignalSetFn","linkedSignalUpdateFn","OutputEmitterRef","destroyed","listeners","errorHandler","optional","destroyRef","constructor","onDestroy","subscribe","callback","ngDevMode","push","unsubscribe","idx","indexOf","undefined","splice","emit","value","console","warn","previousConsumer","listenerFn","err","handleError","getOutputDestroyRef","ref","nonReactiveReadsFn","computed","computation","options","getter","equal","toString","debugName","EffectRefImpl","node","destroy","effect","effectFn","injector","allowSignalWrites","manualCleanup","get","viewContext","notifier","createViewEffect","view","_lView","createRootEffect","onDestroyFn","effectRef","prevInjectorProfilerContext","token","BASE_EFFECT_NODE","consumerIsAlwaysLive","consumerAllowSignalWrites","dirty","hasRun","cleanupFns","zone","kind","run","Error","registerCleanupFn","cleanupFn","prevNode","prevRefreshingViews","maybeCleanup","fn","length","prevConsumer","pop","ROOT_EFFECT_NODE","consumerMarkedDirty","scheduler","schedule","notify","remove","VIEW_EFFECT_NODE","delete","Object","create","Zone","current","Set","add","identityFn","v","linkedSignal","optionsOrComputation","upgradeLinkedSignalGetter","source","upgradedGetter","set","newValue","update","updateFn","asReadonly","bind","RESOURCE_VALUE_THROWS_ERRORS_DEFAULT","resource","oldNameForParams","request","params","ResourceImpl","getLoader","defaultValue","wrapEqualityFn","BaseWritableResource","isError","status","isLoading","hasValue","loaderFn","pendingTasks","state","extRequest","pendingController","resolvePendingTask","unregisterOnDestroy","throwErrorsFromValue","streamValue","stream","error","isResolved","ResourceValueError","reload","previous","previousStatus","projectStatusOfState","loadEffect","abortInProgressLoad","_this","_asyncToGenerator","currentStatus","abortSignal","AbortController","aborted","encapsulateResourceError","abort","a","b","isStreamingResourceOptions","_ref","loader","_x","apply","arguments","ResourceWrappedError","message","cause","String"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/core/fesm2022/resource.mjs"],"sourcesContent":["/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { inject, ErrorHandler, DestroyRef, RuntimeError, formatRuntimeError, assertNotInReactiveContext, assertInInjectionContext, Injector, ViewContext, ChangeDetectionScheduler, EffectScheduler, setInjectorProfilerContext, emitEffectCreatedEvent, EFFECTS, NodeInjectorDestroyRef, FLAGS, markAncestorsForTraversal, noop, setIsRefreshingViews, signalAsReadonlyFn, PendingTasks, signal } from './root_effect_scheduler.mjs';\r\nimport { setActiveConsumer, createComputed, SIGNAL, consumerDestroy, REACTIVE_NODE, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from './signal.mjs';\r\nimport { untracked as untracked$1, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn } from './untracked.mjs';\r\n\r\n/**\r\n * An `OutputEmitterRef` is created by the `output()` function and can be\r\n * used to emit values to consumers of your directive or component.\r\n *\r\n * Consumers of your directive/component can bind to the output and\r\n * subscribe to changes via the bound event syntax. For example:\r\n *\r\n * ```html\r\n * <my-comp (valueChange)=\"processNewValue($event)\" />\r\n * ```\r\n *\r\n * @publicAPI\r\n */\r\nclass OutputEmitterRef {\r\n    destroyed = false;\r\n    listeners = null;\r\n    errorHandler = inject(ErrorHandler, { optional: true });\r\n    /** @internal */\r\n    destroyRef = inject(DestroyRef);\r\n    constructor() {\r\n        // Clean-up all listeners and mark as destroyed upon destroy.\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n            this.listeners = null;\r\n        });\r\n    }\r\n    subscribe(callback) {\r\n        if (this.destroyed) {\r\n            throw new RuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected subscription to destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.');\r\n        }\r\n        (this.listeners ??= []).push(callback);\r\n        return {\r\n            unsubscribe: () => {\r\n                const idx = this.listeners?.indexOf(callback);\r\n                if (idx !== undefined && idx !== -1) {\r\n                    this.listeners?.splice(idx, 1);\r\n                }\r\n            },\r\n        };\r\n    }\r\n    /** Emits a new value to the output. */\r\n    emit(value) {\r\n        if (this.destroyed) {\r\n            console.warn(formatRuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected emit for destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.'));\r\n            return;\r\n        }\r\n        if (this.listeners === null) {\r\n            return;\r\n        }\r\n        const previousConsumer = setActiveConsumer(null);\r\n        try {\r\n            for (const listenerFn of this.listeners) {\r\n                try {\r\n                    listenerFn(value);\r\n                }\r\n                catch (err) {\r\n                    this.errorHandler?.handleError(err);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            setActiveConsumer(previousConsumer);\r\n        }\r\n    }\r\n}\r\n/** Gets the owning `DestroyRef` for the given output. */\r\nfunction getOutputDestroyRef(ref) {\r\n    return ref.destroyRef;\r\n}\r\n\r\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\r\nfunction untracked(nonReactiveReadsFn) {\r\n    return untracked$1(nonReactiveReadsFn);\r\n}\r\n\r\n/**\r\n * Create a computed `Signal` which derives a reactive value from an expression.\r\n */\r\nfunction computed(computation, options) {\r\n    const getter = createComputed(computation, options?.equal);\r\n    if (ngDevMode) {\r\n        getter.toString = () => `[Computed: ${getter()}]`;\r\n        getter[SIGNAL].debugName = options?.debugName;\r\n    }\r\n    return getter;\r\n}\r\n\r\nclass EffectRefImpl {\r\n    [SIGNAL];\r\n    constructor(node) {\r\n        this[SIGNAL] = node;\r\n    }\r\n    destroy() {\r\n        this[SIGNAL].destroy();\r\n    }\r\n}\r\n/**\r\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\r\n * changes.\r\n *\r\n * Angular has two different kinds of effect: component effects and root effects. Component effects\r\n * are created when `effect()` is called from a component, directive, or within a service of a\r\n * component/directive. Root effects are created when `effect()` is called from outside the\r\n * component tree, such as in a root service.\r\n *\r\n * The two effect types differ in their timing. Component effects run as a component lifecycle\r\n * event during Angular's synchronization (change detection) process, and can safely read input\r\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\r\n * and have no connection to the component tree or change detection.\r\n *\r\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\r\n *\r\n * @publicApi 20.0\r\n */\r\nfunction effect(effectFn, options) {\r\n    ngDevMode &&\r\n        assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' +\r\n            'effect inside the component constructor.');\r\n    if (ngDevMode && !options?.injector) {\r\n        assertInInjectionContext(effect);\r\n    }\r\n    if (ngDevMode && options?.allowSignalWrites !== undefined) {\r\n        console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\r\n    }\r\n    const injector = options?.injector ?? inject(Injector);\r\n    let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\r\n    let node;\r\n    const viewContext = injector.get(ViewContext, null, { optional: true });\r\n    const notifier = injector.get(ChangeDetectionScheduler);\r\n    if (viewContext !== null) {\r\n        // This effect was created in the context of a view, and will be associated with the view.\r\n        node = createViewEffect(viewContext.view, notifier, effectFn);\r\n        if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\r\n            // The effect is being created in the same view as the `DestroyRef` references, so it will be\r\n            // automatically destroyed without the need for an explicit `DestroyRef` registration.\r\n            destroyRef = null;\r\n        }\r\n    }\r\n    else {\r\n        // This effect was created outside the context of a view, and will be scheduled independently.\r\n        node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\r\n    }\r\n    node.injector = injector;\r\n    if (destroyRef !== null) {\r\n        // If we need to register for cleanup, do that here.\r\n        node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\r\n    }\r\n    const effectRef = new EffectRefImpl(node);\r\n    if (ngDevMode) {\r\n        node.debugName = options?.debugName ?? '';\r\n        const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\r\n        try {\r\n            emitEffectCreatedEvent(effectRef);\r\n        }\r\n        finally {\r\n            setInjectorProfilerContext(prevInjectorProfilerContext);\r\n        }\r\n    }\r\n    return effectRef;\r\n}\r\nconst BASE_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...REACTIVE_NODE,\r\n    consumerIsAlwaysLive: true,\r\n    consumerAllowSignalWrites: true,\r\n    dirty: true,\r\n    hasRun: false,\r\n    cleanupFns: undefined,\r\n    zone: null,\r\n    kind: 'effect',\r\n    onDestroyFn: noop,\r\n    run() {\r\n        this.dirty = false;\r\n        if (ngDevMode && isInNotificationPhase()) {\r\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\r\n        }\r\n        if (this.hasRun && !consumerPollProducersForChange(this)) {\r\n            return;\r\n        }\r\n        this.hasRun = true;\r\n        const registerCleanupFn = (cleanupFn) => (this.cleanupFns ??= []).push(cleanupFn);\r\n        const prevNode = consumerBeforeComputation(this);\r\n        // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\r\n        // cause CD to reach the component in question.\r\n        const prevRefreshingViews = setIsRefreshingViews(false);\r\n        try {\r\n            this.maybeCleanup();\r\n            this.fn(registerCleanupFn);\r\n        }\r\n        finally {\r\n            setIsRefreshingViews(prevRefreshingViews);\r\n            consumerAfterComputation(this, prevNode);\r\n        }\r\n    },\r\n    maybeCleanup() {\r\n        if (!this.cleanupFns?.length) {\r\n            return;\r\n        }\r\n        const prevConsumer = setActiveConsumer(null);\r\n        try {\r\n            // Attempt to run the cleanup functions. Regardless of failure or success, we consider\r\n            // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\r\n            // from the cleanup function will still crash the current run of the effect.\r\n            while (this.cleanupFns.length) {\r\n                this.cleanupFns.pop()();\r\n            }\r\n        }\r\n        finally {\r\n            this.cleanupFns = [];\r\n            setActiveConsumer(prevConsumer);\r\n        }\r\n    },\r\n}))();\r\nconst ROOT_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...BASE_EFFECT_NODE,\r\n    consumerMarkedDirty() {\r\n        this.scheduler.schedule(this);\r\n        this.notifier.notify(12 /* NotificationSource.RootEffect */);\r\n    },\r\n    destroy() {\r\n        consumerDestroy(this);\r\n        this.onDestroyFn();\r\n        this.maybeCleanup();\r\n        this.scheduler.remove(this);\r\n    },\r\n}))();\r\nconst VIEW_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...BASE_EFFECT_NODE,\r\n    consumerMarkedDirty() {\r\n        this.view[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\r\n        markAncestorsForTraversal(this.view);\r\n        this.notifier.notify(13 /* NotificationSource.ViewEffect */);\r\n    },\r\n    destroy() {\r\n        consumerDestroy(this);\r\n        this.onDestroyFn();\r\n        this.maybeCleanup();\r\n        this.view[EFFECTS]?.delete(this);\r\n    },\r\n}))();\r\nfunction createViewEffect(view, notifier, fn) {\r\n    const node = Object.create(VIEW_EFFECT_NODE);\r\n    node.view = view;\r\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\r\n    node.notifier = notifier;\r\n    node.fn = fn;\r\n    view[EFFECTS] ??= new Set();\r\n    view[EFFECTS].add(node);\r\n    node.consumerMarkedDirty(node);\r\n    return node;\r\n}\r\nfunction createRootEffect(fn, scheduler, notifier) {\r\n    const node = Object.create(ROOT_EFFECT_NODE);\r\n    node.fn = fn;\r\n    node.scheduler = scheduler;\r\n    node.notifier = notifier;\r\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\r\n    node.scheduler.add(node);\r\n    node.notifier.notify(12 /* NotificationSource.RootEffect */);\r\n    return node;\r\n}\r\n\r\nconst identityFn = (v) => v;\r\nfunction linkedSignal(optionsOrComputation, options) {\r\n    if (typeof optionsOrComputation === 'function') {\r\n        const getter = createLinkedSignal(optionsOrComputation, (identityFn), options?.equal);\r\n        return upgradeLinkedSignalGetter(getter);\r\n    }\r\n    else {\r\n        const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\r\n        return upgradeLinkedSignalGetter(getter);\r\n    }\r\n}\r\nfunction upgradeLinkedSignalGetter(getter) {\r\n    if (ngDevMode) {\r\n        getter.toString = () => `[LinkedSignal: ${getter()}]`;\r\n    }\r\n    const node = getter[SIGNAL];\r\n    const upgradedGetter = getter;\r\n    upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);\r\n    upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);\r\n    upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\r\n    return upgradedGetter;\r\n}\r\n\r\n/**\r\n * Whether a `Resource.value()` should throw an error when the resource is in the error state.\r\n *\r\n * This internal flag is being used to gradually roll out this behavior.\r\n */\r\nconst RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;\r\nfunction resource(options) {\r\n    if (ngDevMode && !options?.injector) {\r\n        assertInInjectionContext(resource);\r\n    }\r\n    const oldNameForParams = options.request;\r\n    const params = (options.params ?? oldNameForParams ?? (() => null));\r\n    return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.injector ?? inject(Injector), RESOURCE_VALUE_THROWS_ERRORS_DEFAULT);\r\n}\r\n/**\r\n * Base class which implements `.value` as a `WritableSignal` by delegating `.set` and `.update`.\r\n */\r\nclass BaseWritableResource {\r\n    value;\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.value.set = this.set.bind(this);\r\n        this.value.update = this.update.bind(this);\r\n        this.value.asReadonly = signalAsReadonlyFn;\r\n    }\r\n    isError = computed(() => this.status() === 'error');\r\n    update(updateFn) {\r\n        this.set(updateFn(untracked(this.value)));\r\n    }\r\n    isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading');\r\n    hasValue() {\r\n        // Note: we specifically read `isError()` instead of `status()` here to avoid triggering\r\n        // reactive consumers which read `hasValue()`. This way, if `hasValue()` is used inside of an\r\n        // effect, it doesn't cause the effect to rerun on every status change.\r\n        if (this.isError()) {\r\n            return false;\r\n        }\r\n        return this.value() !== undefined;\r\n    }\r\n    asReadonly() {\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * Implementation for `resource()` which uses a `linkedSignal` to manage the resource's state.\r\n */\r\nclass ResourceImpl extends BaseWritableResource {\r\n    loaderFn;\r\n    equal;\r\n    pendingTasks;\r\n    /**\r\n     * The current state of the resource. Status, value, and error are derived from this.\r\n     */\r\n    state;\r\n    /**\r\n     * Combines the current request with a reload counter which allows the resource to be reloaded on\r\n     * imperative command.\r\n     */\r\n    extRequest;\r\n    effectRef;\r\n    pendingController;\r\n    resolvePendingTask = undefined;\r\n    destroyed = false;\r\n    unregisterOnDestroy;\r\n    constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {\r\n        super(\r\n        // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\r\n        // `WritableSignal` that delegates to `ResourceImpl.set`.\r\n        computed(() => {\r\n            const streamValue = this.state().stream?.();\r\n            if (!streamValue) {\r\n                return defaultValue;\r\n            }\r\n            // Prevents `hasValue()` from throwing an error when a reload happened in the error state\r\n            if (this.state().status === 'loading' && this.error()) {\r\n                return defaultValue;\r\n            }\r\n            if (!isResolved(streamValue)) {\r\n                if (throwErrorsFromValue) {\r\n                    throw new ResourceValueError(this.error());\r\n                }\r\n                else {\r\n                    return defaultValue;\r\n                }\r\n            }\r\n            return streamValue.value;\r\n        }, { equal }));\r\n        this.loaderFn = loaderFn;\r\n        this.equal = equal;\r\n        // Extend `request()` to include a writable reload signal.\r\n        this.extRequest = linkedSignal({\r\n            source: request,\r\n            computation: (request) => ({ request, reload: 0 }),\r\n        });\r\n        // The main resource state is managed in a `linkedSignal`, which allows the resource to change\r\n        // state instantaneously when the request signal changes.\r\n        this.state = linkedSignal({\r\n            // Whenever the request changes,\r\n            source: this.extRequest,\r\n            // Compute the state of the resource given a change in status.\r\n            computation: (extRequest, previous) => {\r\n                const status = extRequest.request === undefined ? 'idle' : 'loading';\r\n                if (!previous) {\r\n                    return {\r\n                        extRequest,\r\n                        status,\r\n                        previousStatus: 'idle',\r\n                        stream: undefined,\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        extRequest,\r\n                        status,\r\n                        previousStatus: projectStatusOfState(previous.value),\r\n                        // If the request hasn't changed, keep the previous stream.\r\n                        stream: previous.value.extRequest.request === extRequest.request\r\n                            ? previous.value.stream\r\n                            : undefined,\r\n                    };\r\n                }\r\n            },\r\n        });\r\n        this.effectRef = effect(this.loadEffect.bind(this), {\r\n            injector,\r\n            manualCleanup: true,\r\n        });\r\n        this.pendingTasks = injector.get(PendingTasks);\r\n        // Cancel any pending request when the resource itself is destroyed.\r\n        this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());\r\n    }\r\n    status = computed(() => projectStatusOfState(this.state()));\r\n    error = computed(() => {\r\n        const stream = this.state().stream?.();\r\n        return stream && !isResolved(stream) ? stream.error : undefined;\r\n    });\r\n    /**\r\n     * Called either directly via `WritableResource.set` or via `.value.set()`.\r\n     */\r\n    set(value) {\r\n        if (this.destroyed) {\r\n            return;\r\n        }\r\n        const error = untracked(this.error);\r\n        const state = untracked(this.state);\r\n        if (!error) {\r\n            const current = untracked(this.value);\r\n            if (state.status === 'local' &&\r\n                (this.equal ? this.equal(current, value) : current === value)) {\r\n                return;\r\n            }\r\n        }\r\n        // Enter Local state with the user-defined value.\r\n        this.state.set({\r\n            extRequest: state.extRequest,\r\n            status: 'local',\r\n            previousStatus: 'local',\r\n            stream: signal({ value }),\r\n        });\r\n        // We're departing from whatever state the resource was in previously, so cancel any in-progress\r\n        // loading operations.\r\n        this.abortInProgressLoad();\r\n    }\r\n    reload() {\r\n        // We don't want to restart in-progress loads.\r\n        const { status } = untracked(this.state);\r\n        if (status === 'idle' || status === 'loading') {\r\n            return false;\r\n        }\r\n        // Increment the request reload to trigger the `state` linked signal to switch us to `Reload`\r\n        this.extRequest.update(({ request, reload }) => ({ request, reload: reload + 1 }));\r\n        return true;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.unregisterOnDestroy();\r\n        this.effectRef.destroy();\r\n        this.abortInProgressLoad();\r\n        // Destroyed resources enter Idle state.\r\n        this.state.set({\r\n            extRequest: { request: undefined, reload: 0 },\r\n            status: 'idle',\r\n            previousStatus: 'idle',\r\n            stream: undefined,\r\n        });\r\n    }\r\n    async loadEffect() {\r\n        const extRequest = this.extRequest();\r\n        // Capture the previous status before any state transitions. Note that this is `untracked` since\r\n        // we do not want the effect to depend on the state of the resource, only on the request.\r\n        const { status: currentStatus, previousStatus } = untracked(this.state);\r\n        if (extRequest.request === undefined) {\r\n            // Nothing to load (and we should already be in a non-loading state).\r\n            return;\r\n        }\r\n        else if (currentStatus !== 'loading') {\r\n            // We're not in a loading or reloading state, so this loading request is stale.\r\n            return;\r\n        }\r\n        // Cancel any previous loading attempts.\r\n        this.abortInProgressLoad();\r\n        // Capturing _this_ load's pending task in a local variable is important here. We may attempt to\r\n        // resolve it twice:\r\n        //\r\n        //  1. when the loading function promise resolves/rejects\r\n        //  2. when cancelling the loading operation\r\n        //\r\n        // After the loading operation is cancelled, `this.resolvePendingTask` no longer represents this\r\n        // particular task, but this `await` may eventually resolve/reject. Thus, when we cancel in\r\n        // response to (1) below, we need to cancel the locally saved task.\r\n        let resolvePendingTask = (this.resolvePendingTask =\r\n            this.pendingTasks.add());\r\n        const { signal: abortSignal } = (this.pendingController = new AbortController());\r\n        try {\r\n            // The actual loading is run through `untracked` - only the request side of `resource` is\r\n            // reactive. This avoids any confusion with signals tracking or not tracking depending on\r\n            // which side of the `await` they are.\r\n            const stream = await untracked(() => {\r\n                return this.loaderFn({\r\n                    params: extRequest.request,\r\n                    // TODO(alxhub): cleanup after g3 removal of `request` alias.\r\n                    request: extRequest.request,\r\n                    abortSignal,\r\n                    previous: {\r\n                        status: previousStatus,\r\n                    },\r\n                });\r\n            });\r\n            // If this request has been aborted, or the current request no longer\r\n            // matches this load, then we should ignore this resolution.\r\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\r\n                return;\r\n            }\r\n            this.state.set({\r\n                extRequest,\r\n                status: 'resolved',\r\n                previousStatus: 'resolved',\r\n                stream,\r\n            });\r\n        }\r\n        catch (err) {\r\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\r\n                return;\r\n            }\r\n            this.state.set({\r\n                extRequest,\r\n                status: 'resolved',\r\n                previousStatus: 'error',\r\n                stream: signal({ error: encapsulateResourceError(err) }),\r\n            });\r\n        }\r\n        finally {\r\n            // Resolve the pending task now that the resource has a value.\r\n            resolvePendingTask?.();\r\n            resolvePendingTask = undefined;\r\n        }\r\n    }\r\n    abortInProgressLoad() {\r\n        untracked(() => this.pendingController?.abort());\r\n        this.pendingController = undefined;\r\n        // Once the load is aborted, we no longer want to block stability on its resolution.\r\n        this.resolvePendingTask?.();\r\n        this.resolvePendingTask = undefined;\r\n    }\r\n}\r\n/**\r\n * Wraps an equality function to handle either value being `undefined`.\r\n */\r\nfunction wrapEqualityFn(equal) {\r\n    return (a, b) => (a === undefined || b === undefined ? a === b : equal(a, b));\r\n}\r\nfunction getLoader(options) {\r\n    if (isStreamingResourceOptions(options)) {\r\n        return options.stream;\r\n    }\r\n    return async (params) => {\r\n        try {\r\n            return signal({ value: await options.loader(params) });\r\n        }\r\n        catch (err) {\r\n            return signal({ error: encapsulateResourceError(err) });\r\n        }\r\n    };\r\n}\r\nfunction isStreamingResourceOptions(options) {\r\n    return !!options.stream;\r\n}\r\n/**\r\n * Project from a state with `ResourceInternalStatus` to the user-facing `ResourceStatus`\r\n */\r\nfunction projectStatusOfState(state) {\r\n    switch (state.status) {\r\n        case 'loading':\r\n            return state.extRequest.reload === 0 ? 'loading' : 'reloading';\r\n        case 'resolved':\r\n            return isResolved(state.stream()) ? 'resolved' : 'error';\r\n        default:\r\n            return state.status;\r\n    }\r\n}\r\nfunction isResolved(state) {\r\n    return state.error === undefined;\r\n}\r\nfunction encapsulateResourceError(error) {\r\n    if (error instanceof Error) {\r\n        return error;\r\n    }\r\n    return new ResourceWrappedError(error);\r\n}\r\nclass ResourceValueError extends Error {\r\n    constructor(error) {\r\n        super(ngDevMode\r\n            ? `Resource is currently in an error state (see Error.cause for details): ${error.message}`\r\n            : error.message, { cause: error });\r\n    }\r\n}\r\nclass ResourceWrappedError extends Error {\r\n    constructor(error) {\r\n        super(ngDevMode\r\n            ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.`\r\n            : String(error), { cause: error });\r\n    }\r\n}\r\n\r\nexport { OutputEmitterRef, ResourceImpl, computed, effect, encapsulateResourceError, getOutputDestroyRef, linkedSignal, resource, untracked };\r\n\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;;AAEA,SAASA,MAAM,EAAEC,YAAY,EAAEC,UAAU,EAAEC,YAAY,EAAEC,kBAAkB,EAAEC,0BAA0B,EAAEC,wBAAwB,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,wBAAwB,EAAEC,eAAe,EAAEC,0BAA0B,EAAEC,sBAAsB,EAAEC,OAAO,EAAEC,sBAAsB,EAAEC,KAAK,EAAEC,yBAAyB,EAAEC,IAAI,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,YAAY,EAAEC,MAAM,QAAQ,6BAA6B;AACra,SAASC,iBAAiB,EAAEC,cAAc,EAAEC,MAAM,EAAEC,eAAe,EAAEC,aAAa,EAAEC,qBAAqB,EAAEC,8BAA8B,EAAEC,yBAAyB,EAAEC,wBAAwB,QAAQ,cAAc;AACpN,SAASC,SAAS,IAAIC,WAAW,EAAEC,kBAAkB,EAAEC,iBAAiB,EAAEC,oBAAoB,QAAQ,iBAAiB;;AAEvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,CAAC;EACnBC,SAAS,GAAG,KAAK;EACjBC,SAAS,GAAG,IAAI;EAChBC,YAAY,GAAGvC,MAAM,CAACC,YAAY,EAAE;IAAEuC,QAAQ,EAAE;EAAK,CAAC,CAAC;EACvD;EACAC,UAAU,GAAGzC,MAAM,CAACE,UAAU,CAAC;EAC/BwC,WAAWA,CAAA,EAAG;IACV;IACA,IAAI,CAACD,UAAU,CAACE,SAAS,CAAC,MAAM;MAC5B,IAAI,CAACN,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,SAAS,GAAG,IAAI;IACzB,CAAC,CAAC;EACN;EACAM,SAASA,CAACC,QAAQ,EAAE;IAChB,IAAI,IAAI,CAACR,SAAS,EAAE;MAChB,MAAM,IAAIlC,YAAY,CAAC,GAAG,CAAC,6CAA6C2C,SAAS,IAC7E,oDAAoD,GAChD,8CAA8C,CAAC;IAC3D;IACA,CAAC,IAAI,CAACR,SAAS,KAAK,EAAE,EAAES,IAAI,CAACF,QAAQ,CAAC;IACtC,OAAO;MACHG,WAAW,EAAEA,CAAA,KAAM;QACf,MAAMC,GAAG,GAAG,IAAI,CAACX,SAAS,EAAEY,OAAO,CAACL,QAAQ,CAAC;QAC7C,IAAII,GAAG,KAAKE,SAAS,IAAIF,GAAG,KAAK,CAAC,CAAC,EAAE;UACjC,IAAI,CAACX,SAAS,EAAEc,MAAM,CAACH,GAAG,EAAE,CAAC,CAAC;QAClC;MACJ;IACJ,CAAC;EACL;EACA;EACAI,IAAIA,CAACC,KAAK,EAAE;IACR,IAAI,IAAI,CAACjB,SAAS,EAAE;MAChBkB,OAAO,CAACC,IAAI,CAACpD,kBAAkB,CAAC,GAAG,CAAC,6CAA6C0C,SAAS,IACtF,6CAA6C,GACzC,8CAA8C,CAAC,CAAC;MACxD;IACJ;IACA,IAAI,IAAI,CAACR,SAAS,KAAK,IAAI,EAAE;MACzB;IACJ;IACA,MAAMmB,gBAAgB,GAAGnC,iBAAiB,CAAC,IAAI,CAAC;IAChD,IAAI;MACA,KAAK,MAAMoC,UAAU,IAAI,IAAI,CAACpB,SAAS,EAAE;QACrC,IAAI;UACAoB,UAAU,CAACJ,KAAK,CAAC;QACrB,CAAC,CACD,OAAOK,GAAG,EAAE;UACR,IAAI,CAACpB,YAAY,EAAEqB,WAAW,CAACD,GAAG,CAAC;QACvC;MACJ;IACJ,CAAC,SACO;MACJrC,iBAAiB,CAACmC,gBAAgB,CAAC;IACvC;EACJ;AACJ;AACA;AACA,SAASI,mBAAmBA,CAACC,GAAG,EAAE;EAC9B,OAAOA,GAAG,CAACrB,UAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA,SAASV,SAASA,CAACgC,kBAAkB,EAAE;EACnC,OAAO/B,WAAW,CAAC+B,kBAAkB,CAAC;AAC1C;;AAEA;AACA;AACA;AACA,SAASC,QAAQA,CAACC,WAAW,EAAEC,OAAO,EAAE;EACpC,MAAMC,MAAM,GAAG5C,cAAc,CAAC0C,WAAW,EAAEC,OAAO,EAAEE,KAAK,CAAC;EAC1D,IAAItB,SAAS,EAAE;IACXqB,MAAM,CAACE,QAAQ,GAAG,MAAM,cAAcF,MAAM,CAAC,CAAC,GAAG;IACjDA,MAAM,CAAC3C,MAAM,CAAC,CAAC8C,SAAS,GAAGJ,OAAO,EAAEI,SAAS;EACjD;EACA,OAAOH,MAAM;AACjB;AAEA,MAAMI,aAAa,CAAC;EAChB,CAAC/C,MAAM;EACPkB,WAAWA,CAAC8B,IAAI,EAAE;IACd,IAAI,CAAChD,MAAM,CAAC,GAAGgD,IAAI;EACvB;EACAC,OAAOA,CAAA,EAAG;IACN,IAAI,CAACjD,MAAM,CAAC,CAACiD,OAAO,CAAC,CAAC;EAC1B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,QAAQ,EAAET,OAAO,EAAE;EAC/BpB,SAAS,IACLzC,0BAA0B,CAACqE,MAAM,EAAE,yEAAyE,GACxG,0CAA0C,CAAC;EACnD,IAAI5B,SAAS,IAAI,CAACoB,OAAO,EAAEU,QAAQ,EAAE;IACjCtE,wBAAwB,CAACoE,MAAM,CAAC;EACpC;EACA,IAAI5B,SAAS,IAAIoB,OAAO,EAAEW,iBAAiB,KAAK1B,SAAS,EAAE;IACvDI,OAAO,CAACC,IAAI,CAAC,uGAAuG,CAAC;EACzH;EACA,MAAMoB,QAAQ,GAAGV,OAAO,EAAEU,QAAQ,IAAI5E,MAAM,CAACO,QAAQ,CAAC;EACtD,IAAIkC,UAAU,GAAGyB,OAAO,EAAEY,aAAa,KAAK,IAAI,GAAGF,QAAQ,CAACG,GAAG,CAAC7E,UAAU,CAAC,GAAG,IAAI;EAClF,IAAIsE,IAAI;EACR,MAAMQ,WAAW,GAAGJ,QAAQ,CAACG,GAAG,CAACvE,WAAW,EAAE,IAAI,EAAE;IAAEgC,QAAQ,EAAE;EAAK,CAAC,CAAC;EACvE,MAAMyC,QAAQ,GAAGL,QAAQ,CAACG,GAAG,CAACtE,wBAAwB,CAAC;EACvD,IAAIuE,WAAW,KAAK,IAAI,EAAE;IACtB;IACAR,IAAI,GAAGU,gBAAgB,CAACF,WAAW,CAACG,IAAI,EAAEF,QAAQ,EAAEN,QAAQ,CAAC;IAC7D,IAAIlC,UAAU,YAAY3B,sBAAsB,IAAI2B,UAAU,CAAC2C,MAAM,KAAKJ,WAAW,CAACG,IAAI,EAAE;MACxF;MACA;MACA1C,UAAU,GAAG,IAAI;IACrB;EACJ,CAAC,MACI;IACD;IACA+B,IAAI,GAAGa,gBAAgB,CAACV,QAAQ,EAAEC,QAAQ,CAACG,GAAG,CAACrE,eAAe,CAAC,EAAEuE,QAAQ,CAAC;EAC9E;EACAT,IAAI,CAACI,QAAQ,GAAGA,QAAQ;EACxB,IAAInC,UAAU,KAAK,IAAI,EAAE;IACrB;IACA+B,IAAI,CAACc,WAAW,GAAG7C,UAAU,CAACE,SAAS,CAAC,MAAM6B,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EACjE;EACA,MAAMc,SAAS,GAAG,IAAIhB,aAAa,CAACC,IAAI,CAAC;EACzC,IAAI1B,SAAS,EAAE;IACX0B,IAAI,CAACF,SAAS,GAAGJ,OAAO,EAAEI,SAAS,IAAI,EAAE;IACzC,MAAMkB,2BAA2B,GAAG7E,0BAA0B,CAAC;MAAEiE,QAAQ;MAAEa,KAAK,EAAE;IAAK,CAAC,CAAC;IACzF,IAAI;MACA7E,sBAAsB,CAAC2E,SAAS,CAAC;IACrC,CAAC,SACO;MACJ5E,0BAA0B,CAAC6E,2BAA2B,CAAC;IAC3D;EACJ;EACA,OAAOD,SAAS;AACpB;AACA,MAAMG,gBAAgB,GACtB,eAAgB,CAAC,OAAO;EACpB,GAAGhE,aAAa;EAChBiE,oBAAoB,EAAE,IAAI;EAC1BC,yBAAyB,EAAE,IAAI;EAC/BC,KAAK,EAAE,IAAI;EACXC,MAAM,EAAE,KAAK;EACbC,UAAU,EAAE5C,SAAS;EACrB6C,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE,QAAQ;EACdX,WAAW,EAAErE,IAAI;EACjBiF,GAAGA,CAAA,EAAG;IACF,IAAI,CAACL,KAAK,GAAG,KAAK;IAClB,IAAI/C,SAAS,IAAInB,qBAAqB,CAAC,CAAC,EAAE;MACtC,MAAM,IAAIwE,KAAK,CAAC,mEAAmE,CAAC;IACxF;IACA,IAAI,IAAI,CAACL,MAAM,IAAI,CAAClE,8BAA8B,CAAC,IAAI,CAAC,EAAE;MACtD;IACJ;IACA,IAAI,CAACkE,MAAM,GAAG,IAAI;IAClB,MAAMM,iBAAiB,GAAIC,SAAS,IAAK,CAAC,IAAI,CAACN,UAAU,KAAK,EAAE,EAAEhD,IAAI,CAACsD,SAAS,CAAC;IACjF,MAAMC,QAAQ,GAAGzE,yBAAyB,CAAC,IAAI,CAAC;IAChD;IACA;IACA,MAAM0E,mBAAmB,GAAGrF,oBAAoB,CAAC,KAAK,CAAC;IACvD,IAAI;MACA,IAAI,CAACsF,YAAY,CAAC,CAAC;MACnB,IAAI,CAACC,EAAE,CAACL,iBAAiB,CAAC;IAC9B,CAAC,SACO;MACJlF,oBAAoB,CAACqF,mBAAmB,CAAC;MACzCzE,wBAAwB,CAAC,IAAI,EAAEwE,QAAQ,CAAC;IAC5C;EACJ,CAAC;EACDE,YAAYA,CAAA,EAAG;IACX,IAAI,CAAC,IAAI,CAACT,UAAU,EAAEW,MAAM,EAAE;MAC1B;IACJ;IACA,MAAMC,YAAY,GAAGrF,iBAAiB,CAAC,IAAI,CAAC;IAC5C,IAAI;MACA;MACA;MACA;MACA,OAAO,IAAI,CAACyE,UAAU,CAACW,MAAM,EAAE;QAC3B,IAAI,CAACX,UAAU,CAACa,GAAG,CAAC,CAAC,CAAC,CAAC;MAC3B;IACJ,CAAC,SACO;MACJ,IAAI,CAACb,UAAU,GAAG,EAAE;MACpBzE,iBAAiB,CAACqF,YAAY,CAAC;IACnC;EACJ;AACJ,CAAC,CAAC,EAAE,CAAC;AACL,MAAME,gBAAgB,GACtB,eAAgB,CAAC,OAAO;EACpB,GAAGnB,gBAAgB;EACnBoB,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC,IAAI,CAAC;IAC7B,IAAI,CAAC/B,QAAQ,CAACgC,MAAM,CAAC,EAAE,CAAC,mCAAmC,CAAC;EAChE,CAAC;EACDxC,OAAOA,CAAA,EAAG;IACNhD,eAAe,CAAC,IAAI,CAAC;IACrB,IAAI,CAAC6D,WAAW,CAAC,CAAC;IAClB,IAAI,CAACkB,YAAY,CAAC,CAAC;IACnB,IAAI,CAACO,SAAS,CAACG,MAAM,CAAC,IAAI,CAAC;EAC/B;AACJ,CAAC,CAAC,EAAE,CAAC;AACL,MAAMC,gBAAgB,GACtB,eAAgB,CAAC,OAAO;EACpB,GAAGzB,gBAAgB;EACnBoB,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAC3B,IAAI,CAACpE,KAAK,CAAC,IAAI,IAAI,CAAC;IACzBC,yBAAyB,CAAC,IAAI,CAACmE,IAAI,CAAC;IACpC,IAAI,CAACF,QAAQ,CAACgC,MAAM,CAAC,EAAE,CAAC,mCAAmC,CAAC;EAChE,CAAC;EACDxC,OAAOA,CAAA,EAAG;IACNhD,eAAe,CAAC,IAAI,CAAC;IACrB,IAAI,CAAC6D,WAAW,CAAC,CAAC;IAClB,IAAI,CAACkB,YAAY,CAAC,CAAC;IACnB,IAAI,CAACrB,IAAI,CAACtE,OAAO,CAAC,EAAEuG,MAAM,CAAC,IAAI,CAAC;EACpC;AACJ,CAAC,CAAC,EAAE,CAAC;AACL,SAASlC,gBAAgBA,CAACC,IAAI,EAAEF,QAAQ,EAAEwB,EAAE,EAAE;EAC1C,MAAMjC,IAAI,GAAG6C,MAAM,CAACC,MAAM,CAACH,gBAAgB,CAAC;EAC5C3C,IAAI,CAACW,IAAI,GAAGA,IAAI;EAChBX,IAAI,CAACwB,IAAI,GAAG,OAAOuB,IAAI,KAAK,WAAW,GAAGA,IAAI,CAACC,OAAO,GAAG,IAAI;EAC7DhD,IAAI,CAACS,QAAQ,GAAGA,QAAQ;EACxBT,IAAI,CAACiC,EAAE,GAAGA,EAAE;EACZtB,IAAI,CAACtE,OAAO,CAAC,KAAK,IAAI4G,GAAG,CAAC,CAAC;EAC3BtC,IAAI,CAACtE,OAAO,CAAC,CAAC6G,GAAG,CAAClD,IAAI,CAAC;EACvBA,IAAI,CAACsC,mBAAmB,CAACtC,IAAI,CAAC;EAC9B,OAAOA,IAAI;AACf;AACA,SAASa,gBAAgBA,CAACoB,EAAE,EAAEM,SAAS,EAAE9B,QAAQ,EAAE;EAC/C,MAAMT,IAAI,GAAG6C,MAAM,CAACC,MAAM,CAACT,gBAAgB,CAAC;EAC5CrC,IAAI,CAACiC,EAAE,GAAGA,EAAE;EACZjC,IAAI,CAACuC,SAAS,GAAGA,SAAS;EAC1BvC,IAAI,CAACS,QAAQ,GAAGA,QAAQ;EACxBT,IAAI,CAACwB,IAAI,GAAG,OAAOuB,IAAI,KAAK,WAAW,GAAGA,IAAI,CAACC,OAAO,GAAG,IAAI;EAC7DhD,IAAI,CAACuC,SAAS,CAACW,GAAG,CAAClD,IAAI,CAAC;EACxBA,IAAI,CAACS,QAAQ,CAACgC,MAAM,CAAC,EAAE,CAAC,mCAAmC,CAAC;EAC5D,OAAOzC,IAAI;AACf;AAEA,MAAMmD,UAAU,GAAIC,CAAC,IAAKA,CAAC;AAC3B,SAASC,YAAYA,CAACC,oBAAoB,EAAE5D,OAAO,EAAE;EACjD,IAAI,OAAO4D,oBAAoB,KAAK,UAAU,EAAE;IAC5C,MAAM3D,MAAM,GAAGlC,kBAAkB,CAAC6F,oBAAoB,EAAGH,UAAU,EAAGzD,OAAO,EAAEE,KAAK,CAAC;IACrF,OAAO2D,yBAAyB,CAAC5D,MAAM,CAAC;EAC5C,CAAC,MACI;IACD,MAAMA,MAAM,GAAGlC,kBAAkB,CAAC6F,oBAAoB,CAACE,MAAM,EAAEF,oBAAoB,CAAC7D,WAAW,EAAE6D,oBAAoB,CAAC1D,KAAK,CAAC;IAC5H,OAAO2D,yBAAyB,CAAC5D,MAAM,CAAC;EAC5C;AACJ;AACA,SAAS4D,yBAAyBA,CAAC5D,MAAM,EAAE;EACvC,IAAIrB,SAAS,EAAE;IACXqB,MAAM,CAACE,QAAQ,GAAG,MAAM,kBAAkBF,MAAM,CAAC,CAAC,GAAG;EACzD;EACA,MAAMK,IAAI,GAAGL,MAAM,CAAC3C,MAAM,CAAC;EAC3B,MAAMyG,cAAc,GAAG9D,MAAM;EAC7B8D,cAAc,CAACC,GAAG,GAAIC,QAAQ,IAAKjG,iBAAiB,CAACsC,IAAI,EAAE2D,QAAQ,CAAC;EACpEF,cAAc,CAACG,MAAM,GAAIC,QAAQ,IAAKlG,oBAAoB,CAACqC,IAAI,EAAE6D,QAAQ,CAAC;EAC1EJ,cAAc,CAACK,UAAU,GAAGnH,kBAAkB,CAACoH,IAAI,CAACpE,MAAM,CAAC;EAC3D,OAAO8D,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMO,oCAAoC,GAAG,IAAI;AACjD,SAASC,QAAQA,CAACvE,OAAO,EAAE;EACvB,IAAIpB,SAAS,IAAI,CAACoB,OAAO,EAAEU,QAAQ,EAAE;IACjCtE,wBAAwB,CAACmI,QAAQ,CAAC;EACtC;EACA,MAAMC,gBAAgB,GAAGxE,OAAO,CAACyE,OAAO;EACxC,MAAMC,MAAM,GAAI1E,OAAO,CAAC0E,MAAM,IAAIF,gBAAgB,KAAK,MAAM,IAAI,CAAE;EACnE,OAAO,IAAIG,YAAY,CAACD,MAAM,EAAEE,SAAS,CAAC5E,OAAO,CAAC,EAAEA,OAAO,CAAC6E,YAAY,EAAE7E,OAAO,CAACE,KAAK,GAAG4E,cAAc,CAAC9E,OAAO,CAACE,KAAK,CAAC,GAAGjB,SAAS,EAAEe,OAAO,CAACU,QAAQ,IAAI5E,MAAM,CAACO,QAAQ,CAAC,EAAEiI,oCAAoC,CAAC;AACpN;AACA;AACA;AACA;AACA,MAAMS,oBAAoB,CAAC;EACvB3F,KAAK;EACLZ,WAAWA,CAACY,KAAK,EAAE;IACf,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACA,KAAK,CAAC4E,GAAG,GAAG,IAAI,CAACA,GAAG,CAACK,IAAI,CAAC,IAAI,CAAC;IACpC,IAAI,CAACjF,KAAK,CAAC8E,MAAM,GAAG,IAAI,CAACA,MAAM,CAACG,IAAI,CAAC,IAAI,CAAC;IAC1C,IAAI,CAACjF,KAAK,CAACgF,UAAU,GAAGnH,kBAAkB;EAC9C;EACA+H,OAAO,GAAGlF,QAAQ,CAAC,MAAM,IAAI,CAACmF,MAAM,CAAC,CAAC,KAAK,OAAO,CAAC;EACnDf,MAAMA,CAACC,QAAQ,EAAE;IACb,IAAI,CAACH,GAAG,CAACG,QAAQ,CAACtG,SAAS,CAAC,IAAI,CAACuB,KAAK,CAAC,CAAC,CAAC;EAC7C;EACA8F,SAAS,GAAGpF,QAAQ,CAAC,MAAM,IAAI,CAACmF,MAAM,CAAC,CAAC,KAAK,SAAS,IAAI,IAAI,CAACA,MAAM,CAAC,CAAC,KAAK,WAAW,CAAC;EACxFE,QAAQA,CAAA,EAAG;IACP;IACA;IACA;IACA,IAAI,IAAI,CAACH,OAAO,CAAC,CAAC,EAAE;MAChB,OAAO,KAAK;IAChB;IACA,OAAO,IAAI,CAAC5F,KAAK,CAAC,CAAC,KAAKH,SAAS;EACrC;EACAmF,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI;EACf;AACJ;AACA;AACA;AACA;AACA,MAAMO,YAAY,SAASI,oBAAoB,CAAC;EAC5CK,QAAQ;EACRlF,KAAK;EACLmF,YAAY;EACZ;AACJ;AACA;EACIC,KAAK;EACL;AACJ;AACA;AACA;EACIC,UAAU;EACVlE,SAAS;EACTmE,iBAAiB;EACjBC,kBAAkB,GAAGxG,SAAS;EAC9Bd,SAAS,GAAG,KAAK;EACjBuH,mBAAmB;EACnBlH,WAAWA,CAACiG,OAAO,EAAEW,QAAQ,EAAEP,YAAY,EAAE3E,KAAK,EAAEQ,QAAQ,EAAEiF,oBAAoB,GAAGrB,oCAAoC,EAAE;IACvH,KAAK;IACL;IACA;IACAxE,QAAQ,CAAC,MAAM;MACX,MAAM8F,WAAW,GAAG,IAAI,CAACN,KAAK,CAAC,CAAC,CAACO,MAAM,GAAG,CAAC;MAC3C,IAAI,CAACD,WAAW,EAAE;QACd,OAAOf,YAAY;MACvB;MACA;MACA,IAAI,IAAI,CAACS,KAAK,CAAC,CAAC,CAACL,MAAM,KAAK,SAAS,IAAI,IAAI,CAACa,KAAK,CAAC,CAAC,EAAE;QACnD,OAAOjB,YAAY;MACvB;MACA,IAAI,CAACkB,UAAU,CAACH,WAAW,CAAC,EAAE;QAC1B,IAAID,oBAAoB,EAAE;UACtB,MAAM,IAAIK,kBAAkB,CAAC,IAAI,CAACF,KAAK,CAAC,CAAC,CAAC;QAC9C,CAAC,MACI;UACD,OAAOjB,YAAY;QACvB;MACJ;MACA,OAAOe,WAAW,CAACxG,KAAK;IAC5B,CAAC,EAAE;MAAEc;IAAM,CAAC,CAAC,CAAC;IACd,IAAI,CAACkF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAClF,KAAK,GAAGA,KAAK;IAClB;IACA,IAAI,CAACqF,UAAU,GAAG5B,YAAY,CAAC;MAC3BG,MAAM,EAAEW,OAAO;MACf1E,WAAW,EAAG0E,OAAO,KAAM;QAAEA,OAAO;QAAEwB,MAAM,EAAE;MAAE,CAAC;IACrD,CAAC,CAAC;IACF;IACA;IACA,IAAI,CAACX,KAAK,GAAG3B,YAAY,CAAC;MACtB;MACAG,MAAM,EAAE,IAAI,CAACyB,UAAU;MACvB;MACAxF,WAAW,EAAEA,CAACwF,UAAU,EAAEW,QAAQ,KAAK;QACnC,MAAMjB,MAAM,GAAGM,UAAU,CAACd,OAAO,KAAKxF,SAAS,GAAG,MAAM,GAAG,SAAS;QACpE,IAAI,CAACiH,QAAQ,EAAE;UACX,OAAO;YACHX,UAAU;YACVN,MAAM;YACNkB,cAAc,EAAE,MAAM;YACtBN,MAAM,EAAE5G;UACZ,CAAC;QACL,CAAC,MACI;UACD,OAAO;YACHsG,UAAU;YACVN,MAAM;YACNkB,cAAc,EAAEC,oBAAoB,CAACF,QAAQ,CAAC9G,KAAK,CAAC;YACpD;YACAyG,MAAM,EAAEK,QAAQ,CAAC9G,KAAK,CAACmG,UAAU,CAACd,OAAO,KAAKc,UAAU,CAACd,OAAO,GAC1DyB,QAAQ,CAAC9G,KAAK,CAACyG,MAAM,GACrB5G;UACV,CAAC;QACL;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAACoC,SAAS,GAAGb,MAAM,CAAC,IAAI,CAAC6F,UAAU,CAAChC,IAAI,CAAC,IAAI,CAAC,EAAE;MAChD3D,QAAQ;MACRE,aAAa,EAAE;IACnB,CAAC,CAAC;IACF,IAAI,CAACyE,YAAY,GAAG3E,QAAQ,CAACG,GAAG,CAAC3D,YAAY,CAAC;IAC9C;IACA,IAAI,CAACwI,mBAAmB,GAAGhF,QAAQ,CAACG,GAAG,CAAC7E,UAAU,CAAC,CAACyC,SAAS,CAAC,MAAM,IAAI,CAAC8B,OAAO,CAAC,CAAC,CAAC;EACvF;EACA0E,MAAM,GAAGnF,QAAQ,CAAC,MAAMsG,oBAAoB,CAAC,IAAI,CAACd,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3DQ,KAAK,GAAGhG,QAAQ,CAAC,MAAM;IACnB,MAAM+F,MAAM,GAAG,IAAI,CAACP,KAAK,CAAC,CAAC,CAACO,MAAM,GAAG,CAAC;IACtC,OAAOA,MAAM,IAAI,CAACE,UAAU,CAACF,MAAM,CAAC,GAAGA,MAAM,CAACC,KAAK,GAAG7G,SAAS;EACnE,CAAC,CAAC;EACF;AACJ;AACA;EACI+E,GAAGA,CAAC5E,KAAK,EAAE;IACP,IAAI,IAAI,CAACjB,SAAS,EAAE;MAChB;IACJ;IACA,MAAM2H,KAAK,GAAGjI,SAAS,CAAC,IAAI,CAACiI,KAAK,CAAC;IACnC,MAAMR,KAAK,GAAGzH,SAAS,CAAC,IAAI,CAACyH,KAAK,CAAC;IACnC,IAAI,CAACQ,KAAK,EAAE;MACR,MAAMxC,OAAO,GAAGzF,SAAS,CAAC,IAAI,CAACuB,KAAK,CAAC;MACrC,IAAIkG,KAAK,CAACL,MAAM,KAAK,OAAO,KACvB,IAAI,CAAC/E,KAAK,GAAG,IAAI,CAACA,KAAK,CAACoD,OAAO,EAAElE,KAAK,CAAC,GAAGkE,OAAO,KAAKlE,KAAK,CAAC,EAAE;QAC/D;MACJ;IACJ;IACA;IACA,IAAI,CAACkG,KAAK,CAACtB,GAAG,CAAC;MACXuB,UAAU,EAAED,KAAK,CAACC,UAAU;MAC5BN,MAAM,EAAE,OAAO;MACfkB,cAAc,EAAE,OAAO;MACvBN,MAAM,EAAE1I,MAAM,CAAC;QAAEiC;MAAM,CAAC;IAC5B,CAAC,CAAC;IACF;IACA;IACA,IAAI,CAACkH,mBAAmB,CAAC,CAAC;EAC9B;EACAL,MAAMA,CAAA,EAAG;IACL;IACA,MAAM;MAAEhB;IAAO,CAAC,GAAGpH,SAAS,CAAC,IAAI,CAACyH,KAAK,CAAC;IACxC,IAAIL,MAAM,KAAK,MAAM,IAAIA,MAAM,KAAK,SAAS,EAAE;MAC3C,OAAO,KAAK;IAChB;IACA;IACA,IAAI,CAACM,UAAU,CAACrB,MAAM,CAAC,CAAC;MAAEO,OAAO;MAAEwB;IAAO,CAAC,MAAM;MAAExB,OAAO;MAAEwB,MAAM,EAAEA,MAAM,GAAG;IAAE,CAAC,CAAC,CAAC;IAClF,OAAO,IAAI;EACf;EACA1F,OAAOA,CAAA,EAAG;IACN,IAAI,CAACpC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACuH,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACrE,SAAS,CAACd,OAAO,CAAC,CAAC;IACxB,IAAI,CAAC+F,mBAAmB,CAAC,CAAC;IAC1B;IACA,IAAI,CAAChB,KAAK,CAACtB,GAAG,CAAC;MACXuB,UAAU,EAAE;QAAEd,OAAO,EAAExF,SAAS;QAAEgH,MAAM,EAAE;MAAE,CAAC;MAC7ChB,MAAM,EAAE,MAAM;MACdkB,cAAc,EAAE,MAAM;MACtBN,MAAM,EAAE5G;IACZ,CAAC,CAAC;EACN;EACMoH,UAAUA,CAAA,EAAG;IAAA,IAAAE,KAAA;IAAA,OAAAC,iBAAA;MACf,MAAMjB,UAAU,GAAGgB,KAAI,CAAChB,UAAU,CAAC,CAAC;MACpC;MACA;MACA,MAAM;QAAEN,MAAM,EAAEwB,aAAa;QAAEN;MAAe,CAAC,GAAGtI,SAAS,CAAC0I,KAAI,CAACjB,KAAK,CAAC;MACvE,IAAIC,UAAU,CAACd,OAAO,KAAKxF,SAAS,EAAE;QAClC;QACA;MACJ,CAAC,MACI,IAAIwH,aAAa,KAAK,SAAS,EAAE;QAClC;QACA;MACJ;MACA;MACAF,KAAI,CAACD,mBAAmB,CAAC,CAAC;MAC1B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIb,kBAAkB,GAAIc,KAAI,CAACd,kBAAkB,GAC7Cc,KAAI,CAAClB,YAAY,CAAC7B,GAAG,CAAC,CAAE;MAC5B,MAAM;QAAErG,MAAM,EAAEuJ;MAAY,CAAC,GAAIH,KAAI,CAACf,iBAAiB,GAAG,IAAImB,eAAe,CAAC,CAAE;MAChF,IAAI;QACA;QACA;QACA;QACA,MAAMd,MAAM,SAAShI,SAAS,CAAC,MAAM;UACjC,OAAO0I,KAAI,CAACnB,QAAQ,CAAC;YACjBV,MAAM,EAAEa,UAAU,CAACd,OAAO;YAC1B;YACAA,OAAO,EAAEc,UAAU,CAACd,OAAO;YAC3BiC,WAAW;YACXR,QAAQ,EAAE;cACNjB,MAAM,EAAEkB;YACZ;UACJ,CAAC,CAAC;QACN,CAAC,CAAC;QACF;QACA;QACA,IAAIO,WAAW,CAACE,OAAO,IAAI/I,SAAS,CAAC0I,KAAI,CAAChB,UAAU,CAAC,KAAKA,UAAU,EAAE;UAClE;QACJ;QACAgB,KAAI,CAACjB,KAAK,CAACtB,GAAG,CAAC;UACXuB,UAAU;UACVN,MAAM,EAAE,UAAU;UAClBkB,cAAc,EAAE,UAAU;UAC1BN;QACJ,CAAC,CAAC;MACN,CAAC,CACD,OAAOpG,GAAG,EAAE;QACR,IAAIiH,WAAW,CAACE,OAAO,IAAI/I,SAAS,CAAC0I,KAAI,CAAChB,UAAU,CAAC,KAAKA,UAAU,EAAE;UAClE;QACJ;QACAgB,KAAI,CAACjB,KAAK,CAACtB,GAAG,CAAC;UACXuB,UAAU;UACVN,MAAM,EAAE,UAAU;UAClBkB,cAAc,EAAE,OAAO;UACvBN,MAAM,EAAE1I,MAAM,CAAC;YAAE2I,KAAK,EAAEe,wBAAwB,CAACpH,GAAG;UAAE,CAAC;QAC3D,CAAC,CAAC;MACN,CAAC,SACO;QACJ;QACAgG,kBAAkB,GAAG,CAAC;QACtBA,kBAAkB,GAAGxG,SAAS;MAClC;IAAC;EACL;EACAqH,mBAAmBA,CAAA,EAAG;IAClBzI,SAAS,CAAC,MAAM,IAAI,CAAC2H,iBAAiB,EAAEsB,KAAK,CAAC,CAAC,CAAC;IAChD,IAAI,CAACtB,iBAAiB,GAAGvG,SAAS;IAClC;IACA,IAAI,CAACwG,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACA,kBAAkB,GAAGxG,SAAS;EACvC;AACJ;AACA;AACA;AACA;AACA,SAAS6F,cAAcA,CAAC5E,KAAK,EAAE;EAC3B,OAAO,CAAC6G,CAAC,EAAEC,CAAC,KAAMD,CAAC,KAAK9H,SAAS,IAAI+H,CAAC,KAAK/H,SAAS,GAAG8H,CAAC,KAAKC,CAAC,GAAG9G,KAAK,CAAC6G,CAAC,EAAEC,CAAC,CAAE;AACjF;AACA,SAASpC,SAASA,CAAC5E,OAAO,EAAE;EACxB,IAAIiH,0BAA0B,CAACjH,OAAO,CAAC,EAAE;IACrC,OAAOA,OAAO,CAAC6F,MAAM;EACzB;EACA;IAAA,IAAAqB,IAAA,GAAAV,iBAAA,CAAO,WAAO9B,MAAM,EAAK;MACrB,IAAI;QACA,OAAOvH,MAAM,CAAC;UAAEiC,KAAK,QAAQY,OAAO,CAACmH,MAAM,CAACzC,MAAM;QAAE,CAAC,CAAC;MAC1D,CAAC,CACD,OAAOjF,GAAG,EAAE;QACR,OAAOtC,MAAM,CAAC;UAAE2I,KAAK,EAAEe,wBAAwB,CAACpH,GAAG;QAAE,CAAC,CAAC;MAC3D;IACJ,CAAC;IAAA,iBAAA2H,EAAA;MAAA,OAAAF,IAAA,CAAAG,KAAA,OAAAC,SAAA;IAAA;EAAA;AACL;AACA,SAASL,0BAA0BA,CAACjH,OAAO,EAAE;EACzC,OAAO,CAAC,CAACA,OAAO,CAAC6F,MAAM;AAC3B;AACA;AACA;AACA;AACA,SAASO,oBAAoBA,CAACd,KAAK,EAAE;EACjC,QAAQA,KAAK,CAACL,MAAM;IAChB,KAAK,SAAS;MACV,OAAOK,KAAK,CAACC,UAAU,CAACU,MAAM,KAAK,CAAC,GAAG,SAAS,GAAG,WAAW;IAClE,KAAK,UAAU;MACX,OAAOF,UAAU,CAACT,KAAK,CAACO,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,OAAO;IAC5D;MACI,OAAOP,KAAK,CAACL,MAAM;EAC3B;AACJ;AACA,SAASc,UAAUA,CAACT,KAAK,EAAE;EACvB,OAAOA,KAAK,CAACQ,KAAK,KAAK7G,SAAS;AACpC;AACA,SAAS4H,wBAAwBA,CAACf,KAAK,EAAE;EACrC,IAAIA,KAAK,YAAY7D,KAAK,EAAE;IACxB,OAAO6D,KAAK;EAChB;EACA,OAAO,IAAIyB,oBAAoB,CAACzB,KAAK,CAAC;AAC1C;AACA,MAAME,kBAAkB,SAAS/D,KAAK,CAAC;EACnCzD,WAAWA,CAACsH,KAAK,EAAE;IACf,KAAK,CAAClH,SAAS,GACT,0EAA0EkH,KAAK,CAAC0B,OAAO,EAAE,GACzF1B,KAAK,CAAC0B,OAAO,EAAE;MAAEC,KAAK,EAAE3B;IAAM,CAAC,CAAC;EAC1C;AACJ;AACA,MAAMyB,oBAAoB,SAAStF,KAAK,CAAC;EACrCzD,WAAWA,CAACsH,KAAK,EAAE;IACf,KAAK,CAAClH,SAAS,GACT,4DAA4D8I,MAAM,CAAC5B,KAAK,CAAC,mDAAmD,GAC5H4B,MAAM,CAAC5B,KAAK,CAAC,EAAE;MAAE2B,KAAK,EAAE3B;IAAM,CAAC,CAAC;EAC1C;AACJ;AAEA,SAAS5H,gBAAgB,EAAEyG,YAAY,EAAE7E,QAAQ,EAAEU,MAAM,EAAEqG,wBAAwB,EAAElH,mBAAmB,EAAEgE,YAAY,EAAEY,QAAQ,EAAE1G,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}