{"ast":null,"code":"/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer } from './signal.mjs';\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked };","map":{"version":3,"names":["SIGNAL","runPostProducerCreatedFn","producerUpdateValueVersion","signalSetFn","producerMarkClean","signalUpdateFn","REACTIVE_NODE","UNSET","defaultEquals","COMPUTING","consumerBeforeComputation","ERRORED","consumerAfterComputation","producerAccessed","setActiveConsumer","createLinkedSignal","sourceFn","computationFn","equalityFn","node","Object","create","LINKED_SIGNAL_NODE","source","computation","undefined","equal","linkedSignalGetter","value","error","getter","ngDevMode","debugName","toString","linkedSignalSetFn","newValue","linkedSignalUpdateFn","updater","dirty","kind","producerMustRecompute","producerRecomputeValue","Error","oldValue","prevConsumer","newSourceValue","prev","sourceValue","err","version","untracked","nonReactiveReadsFn"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/core/fesm2022/untracked.mjs"],"sourcesContent":["/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer } from './signal.mjs';\r\n\r\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\r\n    const node = Object.create(LINKED_SIGNAL_NODE);\r\n    node.source = sourceFn;\r\n    node.computation = computationFn;\r\n    if (equalityFn != undefined) {\r\n        node.equal = equalityFn;\r\n    }\r\n    const linkedSignalGetter = () => {\r\n        // Check if the value needs updating before returning it.\r\n        producerUpdateValueVersion(node);\r\n        // Record that someone looked at this signal.\r\n        producerAccessed(node);\r\n        if (node.value === ERRORED) {\r\n            throw node.error;\r\n        }\r\n        return node.value;\r\n    };\r\n    const getter = linkedSignalGetter;\r\n    getter[SIGNAL] = node;\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\r\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\r\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\r\n    }\r\n    runPostProducerCreatedFn(node);\r\n    return getter;\r\n}\r\nfunction linkedSignalSetFn(node, newValue) {\r\n    producerUpdateValueVersion(node);\r\n    signalSetFn(node, newValue);\r\n    producerMarkClean(node);\r\n}\r\nfunction linkedSignalUpdateFn(node, updater) {\r\n    producerUpdateValueVersion(node);\r\n    signalUpdateFn(node, updater);\r\n    producerMarkClean(node);\r\n}\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        value: UNSET,\r\n        dirty: true,\r\n        error: null,\r\n        equal: defaultEquals,\r\n        kind: 'linkedSignal',\r\n        producerMustRecompute(node) {\r\n            // Force a recomputation if there's no current value, or if the current value is in the\r\n            // process of being calculated (which should throw an error).\r\n            return node.value === UNSET || node.value === COMPUTING;\r\n        },\r\n        producerRecomputeValue(node) {\r\n            if (node.value === COMPUTING) {\r\n                // Our computation somehow led to a cyclic read of itself.\r\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\r\n            }\r\n            const oldValue = node.value;\r\n            node.value = COMPUTING;\r\n            const prevConsumer = consumerBeforeComputation(node);\r\n            let newValue;\r\n            try {\r\n                const newSourceValue = node.source();\r\n                const prev = oldValue === UNSET || oldValue === ERRORED\r\n                    ? undefined\r\n                    : {\r\n                        source: node.sourceValue,\r\n                        value: oldValue,\r\n                    };\r\n                newValue = node.computation(newSourceValue, prev);\r\n                node.sourceValue = newSourceValue;\r\n            }\r\n            catch (err) {\r\n                newValue = ERRORED;\r\n                node.error = err;\r\n            }\r\n            finally {\r\n                consumerAfterComputation(node, prevConsumer);\r\n            }\r\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\r\n                // No change to `valueVersion` - old and new values are\r\n                // semantically equivalent.\r\n                node.value = oldValue;\r\n                return;\r\n            }\r\n            node.value = newValue;\r\n            node.version++;\r\n        },\r\n    };\r\n})();\r\n\r\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\r\nfunction untracked(nonReactiveReadsFn) {\r\n    const prevConsumer = setActiveConsumer(null);\r\n    // We are not trying to catch any particular errors here, just making sure that the consumers\r\n    // stack is restored in case of errors.\r\n    try {\r\n        return nonReactiveReadsFn();\r\n    }\r\n    finally {\r\n        setActiveConsumer(prevConsumer);\r\n    }\r\n}\r\n\r\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}