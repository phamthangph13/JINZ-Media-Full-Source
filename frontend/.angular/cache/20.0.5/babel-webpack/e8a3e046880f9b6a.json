{"ast":null,"code":"/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { inject, Injector, ɵRuntimeError as _RuntimeError, ɵChangeDetectionScheduler as _ChangeDetectionScheduler, Injectable, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, makeEnvironmentProviders, RendererFactory2, NgZone, ANIMATION_MODULE_TYPE } from '@angular/core';\nimport { DomRendererFactory2 } from '../dom_renderer.mjs';\nconst ANIMATION_PREFIX = '@';\nclass AsyncAnimationRendererFactory {\n  doc;\n  delegate;\n  zone;\n  animationType;\n  moduleImpl;\n  _rendererFactoryPromise = null;\n  scheduler = null;\n  injector = inject(Injector);\n  loadingSchedulerFn = inject(ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN, {\n    optional: true\n  });\n  _engine;\n  /**\r\n   *\r\n   * @param moduleImpl allows to provide a mock implmentation (or will load the animation module)\r\n   */\n  constructor(doc, delegate, zone, animationType, moduleImpl) {\n    this.doc = doc;\n    this.delegate = delegate;\n    this.zone = zone;\n    this.animationType = animationType;\n    this.moduleImpl = moduleImpl;\n  }\n  /** @docs-private */\n  ngOnDestroy() {\n    // When the root view is removed, the renderer defers the actual work to the\n    // `TransitionAnimationEngine` to do this, and the `TransitionAnimationEngine` doesn't actually\n    // remove the DOM node, but just calls `markElementAsRemoved()`. The actual DOM node is not\n    // removed until `TransitionAnimationEngine` \"flushes\".\n    // Note: we already flush on destroy within the `InjectableAnimationEngine`. The injectable\n    // engine is not provided when async animations are used.\n    this._engine?.flush();\n  }\n  /**\r\n   * @internal\r\n   */\n  loadImpl() {\n    // Note on the `.then(m => m)` part below: Closure compiler optimizations in g3 require\n    // `.then` to be present for a dynamic import (or an import should be `await`ed) to detect\n    // the set of imported symbols.\n    const loadFn = () => this.moduleImpl ?? import('@angular/animations/browser').then(m => m);\n    let moduleImplPromise;\n    if (this.loadingSchedulerFn) {\n      moduleImplPromise = this.loadingSchedulerFn(loadFn);\n    } else {\n      moduleImplPromise = loadFn();\n    }\n    return moduleImplPromise.catch(e => {\n      throw new _RuntimeError(5300 /* RuntimeErrorCode.ANIMATION_RENDERER_ASYNC_LOADING_FAILURE */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Async loading for animations package was ' + 'enabled, but loading failed. Angular falls back to using regular rendering. ' + \"No animations will be displayed and their styles won't be applied.\");\n    }).then(({\n      ɵcreateEngine,\n      ɵAnimationRendererFactory\n    }) => {\n      // We can't create the renderer yet because we might need the hostElement and the type\n      // Both are provided in createRenderer().\n      this._engine = ɵcreateEngine(this.animationType, this.doc);\n      const rendererFactory = new ɵAnimationRendererFactory(this.delegate, this._engine, this.zone);\n      this.delegate = rendererFactory;\n      return rendererFactory;\n    });\n  }\n  /**\r\n   * This method is delegating the renderer creation to the factories.\r\n   * It uses default factory while the animation factory isn't loaded\r\n   * and will rely on the animation factory once it is loaded.\r\n   *\r\n   * Calling this method will trigger as side effect the loading of the animation module\r\n   * if the renderered component uses animations.\r\n   */\n  createRenderer(hostElement, rendererType) {\n    const renderer = this.delegate.createRenderer(hostElement, rendererType);\n    if (renderer.ɵtype === 0 /* AnimationRendererType.Regular */) {\n      // The factory is already loaded, this is an animation renderer\n      return renderer;\n    }\n    // We need to prevent the DomRenderer to throw an error because of synthetic properties\n    if (typeof renderer.throwOnSyntheticProps === 'boolean') {\n      renderer.throwOnSyntheticProps = false;\n    }\n    // Using a dynamic renderer to switch the renderer implementation once the module is loaded.\n    const dynamicRenderer = new DynamicDelegationRenderer(renderer);\n    // Kick off the module loading if the component uses animations but the module hasn't been\n    // loaded yet.\n    if (rendererType?.data?.['animation'] && !this._rendererFactoryPromise) {\n      this._rendererFactoryPromise = this.loadImpl();\n    }\n    this._rendererFactoryPromise?.then(animationRendererFactory => {\n      const animationRenderer = animationRendererFactory.createRenderer(hostElement, rendererType);\n      dynamicRenderer.use(animationRenderer);\n      this.scheduler ??= this.injector.get(_ChangeDetectionScheduler, null, {\n        optional: true\n      });\n      this.scheduler?.notify(10 /* NotificationSource.AsyncAnimationsLoaded */);\n    }).catch(e => {\n      // Permanently use regular renderer when loading fails.\n      dynamicRenderer.use(renderer);\n    });\n    return dynamicRenderer;\n  }\n  begin() {\n    this.delegate.begin?.();\n  }\n  end() {\n    this.delegate.end?.();\n  }\n  whenRenderingDone() {\n    return this.delegate.whenRenderingDone?.() ?? Promise.resolve();\n  }\n  /**\r\n   * Used during HMR to clear any cached data about a component.\r\n   * @param componentId ID of the component that is being replaced.\r\n   */\n  componentReplaced(componentId) {\n    // Flush the engine since the renderer destruction waits for animations to be done.\n    this._engine?.flush();\n    this.delegate.componentReplaced?.(componentId);\n  }\n  static ɵfac = function AsyncAnimationRendererFactory_Factory(__ngFactoryType__) {\n    i0.ɵɵinvalidFactory();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsyncAnimationRendererFactory,\n    factory: AsyncAnimationRendererFactory.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AsyncAnimationRendererFactory, [{\n    type: Injectable\n  }], () => [{\n    type: Document\n  }, {\n    type: i0.RendererFactory2\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined\n  }, {\n    type: Promise\n  }], null);\n})();\n/**\r\n * The class allows to dynamicly switch between different renderer implementations\r\n * by changing the delegate renderer.\r\n */\nclass DynamicDelegationRenderer {\n  delegate;\n  // List of callbacks that need to be replayed on the animation renderer once its loaded\n  replay = [];\n  ɵtype = 1 /* AnimationRendererType.Delegated */;\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n  use(impl) {\n    this.delegate = impl;\n    if (this.replay !== null) {\n      // Replay queued actions using the animation renderer to apply\n      // all events and properties collected while loading was in progress.\n      for (const fn of this.replay) {\n        fn(impl);\n      }\n      // Set to `null` to indicate that the queue was processed\n      // and we no longer need to collect events and properties.\n      this.replay = null;\n    }\n  }\n  get data() {\n    return this.delegate.data;\n  }\n  destroy() {\n    this.replay = null;\n    this.delegate.destroy();\n  }\n  createElement(name, namespace) {\n    return this.delegate.createElement(name, namespace);\n  }\n  createComment(value) {\n    return this.delegate.createComment(value);\n  }\n  createText(value) {\n    return this.delegate.createText(value);\n  }\n  get destroyNode() {\n    return this.delegate.destroyNode;\n  }\n  appendChild(parent, newChild) {\n    this.delegate.appendChild(parent, newChild);\n  }\n  insertBefore(parent, newChild, refChild, isMove) {\n    this.delegate.insertBefore(parent, newChild, refChild, isMove);\n  }\n  removeChild(parent, oldChild, isHostElement) {\n    this.delegate.removeChild(parent, oldChild, isHostElement);\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n  }\n  parentNode(node) {\n    return this.delegate.parentNode(node);\n  }\n  nextSibling(node) {\n    return this.delegate.nextSibling(node);\n  }\n  setAttribute(el, name, value, namespace) {\n    this.delegate.setAttribute(el, name, value, namespace);\n  }\n  removeAttribute(el, name, namespace) {\n    this.delegate.removeAttribute(el, name, namespace);\n  }\n  addClass(el, name) {\n    this.delegate.addClass(el, name);\n  }\n  removeClass(el, name) {\n    this.delegate.removeClass(el, name);\n  }\n  setStyle(el, style, value, flags) {\n    this.delegate.setStyle(el, style, value, flags);\n  }\n  removeStyle(el, style, flags) {\n    this.delegate.removeStyle(el, style, flags);\n  }\n  setProperty(el, name, value) {\n    // We need to keep track of animation properties set on default renderer\n    // So we can also set them also on the animation renderer\n    if (this.shouldReplay(name)) {\n      this.replay.push(renderer => renderer.setProperty(el, name, value));\n    }\n    this.delegate.setProperty(el, name, value);\n  }\n  setValue(node, value) {\n    this.delegate.setValue(node, value);\n  }\n  listen(target, eventName, callback, options) {\n    // We need to keep track of animation events registred by the default renderer\n    // So we can also register them against the animation renderer\n    if (this.shouldReplay(eventName)) {\n      this.replay.push(renderer => renderer.listen(target, eventName, callback, options));\n    }\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n  shouldReplay(propOrEventName) {\n    //`null` indicates that we no longer need to collect events and properties\n    return this.replay !== null && propOrEventName.startsWith(ANIMATION_PREFIX);\n  }\n}\n/**\r\n * Provides a custom scheduler function for the async loading of the animation package.\r\n *\r\n * Private token for investigation purposes\r\n */\nconst ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN = new InjectionToken(ngDevMode ? 'async_animation_loading_scheduler_fn' : '');\n\n/**\r\n * Returns the set of dependency-injection providers\r\n * to enable animations in an application. See [animations guide](guide/animations)\r\n * to learn more about animations in Angular.\r\n *\r\n * When you use this function instead of the eager `provideAnimations()`, animations won't be\r\n * rendered until the renderer is loaded.\r\n *\r\n * @usageNotes\r\n *\r\n * The function is useful when you want to enable animations in an application\r\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\r\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\r\n * providers returned by this function to the `providers` list as show below.\r\n *\r\n * ```ts\r\n * bootstrapApplication(RootComponent, {\r\n *   providers: [\r\n *     provideAnimationsAsync()\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * @param type pass `'noop'` as argument to disable animations.\r\n *\r\n * @publicApi\r\n */\nfunction provideAnimationsAsync(type = 'animations') {\n  _performanceMarkFeature('NgAsyncAnimations');\n  // Animations don't work on the server so we switch them over to no-op automatically.\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    type = 'noop';\n  }\n  return makeEnvironmentProviders([{\n    provide: RendererFactory2,\n    useFactory: (doc, renderer, zone) => {\n      return new AsyncAnimationRendererFactory(doc, renderer, zone, type);\n    },\n    deps: [DOCUMENT, DomRendererFactory2, NgZone]\n  }, {\n    provide: ANIMATION_MODULE_TYPE,\n    useValue: type === 'noop' ? 'NoopAnimations' : 'BrowserAnimations'\n  }]);\n}\nexport { provideAnimationsAsync, ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN, AsyncAnimationRendererFactory as ɵAsyncAnimationRendererFactory };","map":{"version":3,"names":["DOCUMENT","i0","inject","Injector","ɵRuntimeError","_RuntimeError","ɵChangeDetectionScheduler","_ChangeDetectionScheduler","Injectable","InjectionToken","ɵperformanceMarkFeature","_performanceMarkFeature","makeEnvironmentProviders","RendererFactory2","NgZone","ANIMATION_MODULE_TYPE","DomRendererFactory2","ANIMATION_PREFIX","AsyncAnimationRendererFactory","doc","delegate","zone","animationType","moduleImpl","_rendererFactoryPromise","scheduler","injector","loadingSchedulerFn","ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN","optional","_engine","constructor","ngOnDestroy","flush","loadImpl","loadFn","then","m","moduleImplPromise","catch","e","ngDevMode","ɵcreateEngine","ɵAnimationRendererFactory","rendererFactory","createRenderer","hostElement","rendererType","renderer","ɵtype","throwOnSyntheticProps","dynamicRenderer","DynamicDelegationRenderer","data","animationRendererFactory","animationRenderer","use","get","notify","begin","end","whenRenderingDone","Promise","resolve","componentReplaced","componentId","ɵfac","AsyncAnimationRendererFactory_Factory","__ngFactoryType__","ɵɵinvalidFactory","ɵprov","ɵɵdefineInjectable","token","factory","ɵsetClassMetadata","type","Document","undefined","replay","impl","fn","destroy","createElement","name","namespace","createComment","value","createText","destroyNode","appendChild","parent","newChild","insertBefore","refChild","isMove","removeChild","oldChild","isHostElement","selectRootElement","selectorOrNode","preserveContent","parentNode","node","nextSibling","setAttribute","el","removeAttribute","addClass","removeClass","setStyle","style","flags","removeStyle","setProperty","shouldReplay","push","setValue","listen","target","eventName","callback","options","propOrEventName","startsWith","provideAnimationsAsync","ngServerMode","provide","useFactory","deps","useValue","ɵAsyncAnimationRendererFactory"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/platform-browser/fesm2022/animations/async.mjs"],"sourcesContent":["/**\r\n * @license Angular v20.0.6\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { DOCUMENT } from '@angular/common';\r\nimport * as i0 from '@angular/core';\r\nimport { inject, Injector, ɵRuntimeError as _RuntimeError, ɵChangeDetectionScheduler as _ChangeDetectionScheduler, Injectable, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, makeEnvironmentProviders, RendererFactory2, NgZone, ANIMATION_MODULE_TYPE } from '@angular/core';\r\nimport { DomRendererFactory2 } from '../dom_renderer.mjs';\r\n\r\nconst ANIMATION_PREFIX = '@';\r\nclass AsyncAnimationRendererFactory {\r\n    doc;\r\n    delegate;\r\n    zone;\r\n    animationType;\r\n    moduleImpl;\r\n    _rendererFactoryPromise = null;\r\n    scheduler = null;\r\n    injector = inject(Injector);\r\n    loadingSchedulerFn = inject(ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN, {\r\n        optional: true,\r\n    });\r\n    _engine;\r\n    /**\r\n     *\r\n     * @param moduleImpl allows to provide a mock implmentation (or will load the animation module)\r\n     */\r\n    constructor(doc, delegate, zone, animationType, moduleImpl) {\r\n        this.doc = doc;\r\n        this.delegate = delegate;\r\n        this.zone = zone;\r\n        this.animationType = animationType;\r\n        this.moduleImpl = moduleImpl;\r\n    }\r\n    /** @docs-private */\r\n    ngOnDestroy() {\r\n        // When the root view is removed, the renderer defers the actual work to the\r\n        // `TransitionAnimationEngine` to do this, and the `TransitionAnimationEngine` doesn't actually\r\n        // remove the DOM node, but just calls `markElementAsRemoved()`. The actual DOM node is not\r\n        // removed until `TransitionAnimationEngine` \"flushes\".\r\n        // Note: we already flush on destroy within the `InjectableAnimationEngine`. The injectable\r\n        // engine is not provided when async animations are used.\r\n        this._engine?.flush();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    loadImpl() {\r\n        // Note on the `.then(m => m)` part below: Closure compiler optimizations in g3 require\r\n        // `.then` to be present for a dynamic import (or an import should be `await`ed) to detect\r\n        // the set of imported symbols.\r\n        const loadFn = () => this.moduleImpl ?? import('@angular/animations/browser').then((m) => m);\r\n        let moduleImplPromise;\r\n        if (this.loadingSchedulerFn) {\r\n            moduleImplPromise = this.loadingSchedulerFn(loadFn);\r\n        }\r\n        else {\r\n            moduleImplPromise = loadFn();\r\n        }\r\n        return moduleImplPromise\r\n            .catch((e) => {\r\n            throw new _RuntimeError(5300 /* RuntimeErrorCode.ANIMATION_RENDERER_ASYNC_LOADING_FAILURE */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                'Async loading for animations package was ' +\r\n                    'enabled, but loading failed. Angular falls back to using regular rendering. ' +\r\n                    \"No animations will be displayed and their styles won't be applied.\");\r\n        })\r\n            .then(({ ɵcreateEngine, ɵAnimationRendererFactory }) => {\r\n            // We can't create the renderer yet because we might need the hostElement and the type\r\n            // Both are provided in createRenderer().\r\n            this._engine = ɵcreateEngine(this.animationType, this.doc);\r\n            const rendererFactory = new ɵAnimationRendererFactory(this.delegate, this._engine, this.zone);\r\n            this.delegate = rendererFactory;\r\n            return rendererFactory;\r\n        });\r\n    }\r\n    /**\r\n     * This method is delegating the renderer creation to the factories.\r\n     * It uses default factory while the animation factory isn't loaded\r\n     * and will rely on the animation factory once it is loaded.\r\n     *\r\n     * Calling this method will trigger as side effect the loading of the animation module\r\n     * if the renderered component uses animations.\r\n     */\r\n    createRenderer(hostElement, rendererType) {\r\n        const renderer = this.delegate.createRenderer(hostElement, rendererType);\r\n        if (renderer.ɵtype === 0 /* AnimationRendererType.Regular */) {\r\n            // The factory is already loaded, this is an animation renderer\r\n            return renderer;\r\n        }\r\n        // We need to prevent the DomRenderer to throw an error because of synthetic properties\r\n        if (typeof renderer.throwOnSyntheticProps === 'boolean') {\r\n            renderer.throwOnSyntheticProps = false;\r\n        }\r\n        // Using a dynamic renderer to switch the renderer implementation once the module is loaded.\r\n        const dynamicRenderer = new DynamicDelegationRenderer(renderer);\r\n        // Kick off the module loading if the component uses animations but the module hasn't been\r\n        // loaded yet.\r\n        if (rendererType?.data?.['animation'] && !this._rendererFactoryPromise) {\r\n            this._rendererFactoryPromise = this.loadImpl();\r\n        }\r\n        this._rendererFactoryPromise\r\n            ?.then((animationRendererFactory) => {\r\n            const animationRenderer = animationRendererFactory.createRenderer(hostElement, rendererType);\r\n            dynamicRenderer.use(animationRenderer);\r\n            this.scheduler ??= this.injector.get(_ChangeDetectionScheduler, null, { optional: true });\r\n            this.scheduler?.notify(10 /* NotificationSource.AsyncAnimationsLoaded */);\r\n        })\r\n            .catch((e) => {\r\n            // Permanently use regular renderer when loading fails.\r\n            dynamicRenderer.use(renderer);\r\n        });\r\n        return dynamicRenderer;\r\n    }\r\n    begin() {\r\n        this.delegate.begin?.();\r\n    }\r\n    end() {\r\n        this.delegate.end?.();\r\n    }\r\n    whenRenderingDone() {\r\n        return this.delegate.whenRenderingDone?.() ?? Promise.resolve();\r\n    }\r\n    /**\r\n     * Used during HMR to clear any cached data about a component.\r\n     * @param componentId ID of the component that is being replaced.\r\n     */\r\n    componentReplaced(componentId) {\r\n        // Flush the engine since the renderer destruction waits for animations to be done.\r\n        this._engine?.flush();\r\n        this.delegate.componentReplaced?.(componentId);\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.6\", ngImport: i0, type: AsyncAnimationRendererFactory, deps: \"invalid\", target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.6\", ngImport: i0, type: AsyncAnimationRendererFactory });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.6\", ngImport: i0, type: AsyncAnimationRendererFactory, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: () => [{ type: Document }, { type: i0.RendererFactory2 }, { type: i0.NgZone }, { type: undefined }, { type: Promise }] });\r\n/**\r\n * The class allows to dynamicly switch between different renderer implementations\r\n * by changing the delegate renderer.\r\n */\r\nclass DynamicDelegationRenderer {\r\n    delegate;\r\n    // List of callbacks that need to be replayed on the animation renderer once its loaded\r\n    replay = [];\r\n    ɵtype = 1 /* AnimationRendererType.Delegated */;\r\n    constructor(delegate) {\r\n        this.delegate = delegate;\r\n    }\r\n    use(impl) {\r\n        this.delegate = impl;\r\n        if (this.replay !== null) {\r\n            // Replay queued actions using the animation renderer to apply\r\n            // all events and properties collected while loading was in progress.\r\n            for (const fn of this.replay) {\r\n                fn(impl);\r\n            }\r\n            // Set to `null` to indicate that the queue was processed\r\n            // and we no longer need to collect events and properties.\r\n            this.replay = null;\r\n        }\r\n    }\r\n    get data() {\r\n        return this.delegate.data;\r\n    }\r\n    destroy() {\r\n        this.replay = null;\r\n        this.delegate.destroy();\r\n    }\r\n    createElement(name, namespace) {\r\n        return this.delegate.createElement(name, namespace);\r\n    }\r\n    createComment(value) {\r\n        return this.delegate.createComment(value);\r\n    }\r\n    createText(value) {\r\n        return this.delegate.createText(value);\r\n    }\r\n    get destroyNode() {\r\n        return this.delegate.destroyNode;\r\n    }\r\n    appendChild(parent, newChild) {\r\n        this.delegate.appendChild(parent, newChild);\r\n    }\r\n    insertBefore(parent, newChild, refChild, isMove) {\r\n        this.delegate.insertBefore(parent, newChild, refChild, isMove);\r\n    }\r\n    removeChild(parent, oldChild, isHostElement) {\r\n        this.delegate.removeChild(parent, oldChild, isHostElement);\r\n    }\r\n    selectRootElement(selectorOrNode, preserveContent) {\r\n        return this.delegate.selectRootElement(selectorOrNode, preserveContent);\r\n    }\r\n    parentNode(node) {\r\n        return this.delegate.parentNode(node);\r\n    }\r\n    nextSibling(node) {\r\n        return this.delegate.nextSibling(node);\r\n    }\r\n    setAttribute(el, name, value, namespace) {\r\n        this.delegate.setAttribute(el, name, value, namespace);\r\n    }\r\n    removeAttribute(el, name, namespace) {\r\n        this.delegate.removeAttribute(el, name, namespace);\r\n    }\r\n    addClass(el, name) {\r\n        this.delegate.addClass(el, name);\r\n    }\r\n    removeClass(el, name) {\r\n        this.delegate.removeClass(el, name);\r\n    }\r\n    setStyle(el, style, value, flags) {\r\n        this.delegate.setStyle(el, style, value, flags);\r\n    }\r\n    removeStyle(el, style, flags) {\r\n        this.delegate.removeStyle(el, style, flags);\r\n    }\r\n    setProperty(el, name, value) {\r\n        // We need to keep track of animation properties set on default renderer\r\n        // So we can also set them also on the animation renderer\r\n        if (this.shouldReplay(name)) {\r\n            this.replay.push((renderer) => renderer.setProperty(el, name, value));\r\n        }\r\n        this.delegate.setProperty(el, name, value);\r\n    }\r\n    setValue(node, value) {\r\n        this.delegate.setValue(node, value);\r\n    }\r\n    listen(target, eventName, callback, options) {\r\n        // We need to keep track of animation events registred by the default renderer\r\n        // So we can also register them against the animation renderer\r\n        if (this.shouldReplay(eventName)) {\r\n            this.replay.push((renderer) => renderer.listen(target, eventName, callback, options));\r\n        }\r\n        return this.delegate.listen(target, eventName, callback, options);\r\n    }\r\n    shouldReplay(propOrEventName) {\r\n        //`null` indicates that we no longer need to collect events and properties\r\n        return this.replay !== null && propOrEventName.startsWith(ANIMATION_PREFIX);\r\n    }\r\n}\r\n/**\r\n * Provides a custom scheduler function for the async loading of the animation package.\r\n *\r\n * Private token for investigation purposes\r\n */\r\nconst ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN = new InjectionToken(ngDevMode ? 'async_animation_loading_scheduler_fn' : '');\r\n\r\n/**\r\n * Returns the set of dependency-injection providers\r\n * to enable animations in an application. See [animations guide](guide/animations)\r\n * to learn more about animations in Angular.\r\n *\r\n * When you use this function instead of the eager `provideAnimations()`, animations won't be\r\n * rendered until the renderer is loaded.\r\n *\r\n * @usageNotes\r\n *\r\n * The function is useful when you want to enable animations in an application\r\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\r\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\r\n * providers returned by this function to the `providers` list as show below.\r\n *\r\n * ```ts\r\n * bootstrapApplication(RootComponent, {\r\n *   providers: [\r\n *     provideAnimationsAsync()\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * @param type pass `'noop'` as argument to disable animations.\r\n *\r\n * @publicApi\r\n */\r\nfunction provideAnimationsAsync(type = 'animations') {\r\n    _performanceMarkFeature('NgAsyncAnimations');\r\n    // Animations don't work on the server so we switch them over to no-op automatically.\r\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\r\n        type = 'noop';\r\n    }\r\n    return makeEnvironmentProviders([\r\n        {\r\n            provide: RendererFactory2,\r\n            useFactory: (doc, renderer, zone) => {\r\n                return new AsyncAnimationRendererFactory(doc, renderer, zone, type);\r\n            },\r\n            deps: [DOCUMENT, DomRendererFactory2, NgZone],\r\n        },\r\n        {\r\n            provide: ANIMATION_MODULE_TYPE,\r\n            useValue: type === 'noop' ? 'NoopAnimations' : 'BrowserAnimations',\r\n        },\r\n    ]);\r\n}\r\n\r\nexport { provideAnimationsAsync, ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN, AsyncAnimationRendererFactory as ɵAsyncAnimationRendererFactory };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}