{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform, getSupportedInputTypes } from '@angular/cdk/platform';\nimport { AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, NgZone, Renderer2, isSignal, effect, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\nimport { _IdGenerator } from '@angular/cdk/a11y';\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { M as MAT_INPUT_VALUE_ACCESSOR } from './input-value-accessor-D1GvPuqO.mjs';\nimport { h as MAT_FORM_FIELD, k as MatFormFieldControl } from './form-field-CFbrnFED.mjs';\nexport { b as MatError, j as MatFormField, c as MatHint, M as MatLabel, e as MatPrefix, g as MatSuffix } from './form-field-CFbrnFED.mjs';\nimport { E as ErrorStateMatcher } from './error-options-DCNQlTOA.mjs';\nimport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\nimport { M as MatFormFieldModule } from './module-B62K-792.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/cdk/bidi';\nimport '@angular/common';\nimport 'rxjs/operators';\nimport '@angular/cdk/observers/private';\nimport './animation-DfMFjxHu.mjs';\nimport '@angular/cdk/layout';\nimport '@angular/cdk/observers';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\n/** Injection token that can be used to provide the default options for the input. */\nconst MAT_INPUT_CONFIG = new InjectionToken('MAT_INPUT_CONFIG');\nclass MatInput {\n  _elementRef = inject(ElementRef);\n  _platform = inject(Platform);\n  ngControl = inject(NgControl, {\n    optional: true,\n    self: true\n  });\n  _autofillMonitor = inject(AutofillMonitor);\n  _ngZone = inject(NgZone);\n  _formField = inject(MAT_FORM_FIELD, {\n    optional: true\n  });\n  _renderer = inject(Renderer2);\n  _uid = inject(_IdGenerator).getId('mat-input-');\n  _previousNativeValue;\n  _inputValueAccessor;\n  _signalBasedValueAccessor;\n  _previousPlaceholder;\n  _errorStateTracker;\n  _config = inject(MAT_INPUT_CONFIG, {\n    optional: true\n  });\n  _cleanupIosKeyup;\n  _cleanupWebkitWheel;\n  /** Whether the component is being rendered on the server. */\n  _isServer;\n  /** Whether the component is a native html select. */\n  _isNativeSelect;\n  /** Whether the component is a textarea. */\n  _isTextarea;\n  /** Whether the input is inside of a form field. */\n  _isInFormField;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  focused = false;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  stateChanges = new Subject();\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  controlType = 'mat-input';\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  autofilled = false;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  _disabled = false;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get id() {\n    return this._id;\n  }\n  set id(value) {\n    this._id = value || this._uid;\n  }\n  _id;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  placeholder;\n  /**\r\n   * Name of the input.\r\n   * @docs-private\r\n   */\n  name;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get required() {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  _required;\n  /** Input type of the element. */\n  get type() {\n    return this._type;\n  }\n  set type(value) {\n    this._type = value || 'text';\n    this._validateType();\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      this._elementRef.nativeElement.type = this._type;\n    }\n  }\n  _type = 'text';\n  /** An object used to control when error messages are shown. */\n  get errorStateMatcher() {\n    return this._errorStateTracker.matcher;\n  }\n  set errorStateMatcher(value) {\n    this._errorStateTracker.matcher = value;\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  userAriaDescribedBy;\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get value() {\n    return this._signalBasedValueAccessor ? this._signalBasedValueAccessor.value() : this._inputValueAccessor.value;\n  }\n  set value(value) {\n    if (value !== this.value) {\n      if (this._signalBasedValueAccessor) {\n        this._signalBasedValueAccessor.value.set(value);\n      } else {\n        this._inputValueAccessor.value = value;\n      }\n      this.stateChanges.next();\n    }\n  }\n  /** Whether the element is readonly. */\n  get readonly() {\n    return this._readonly;\n  }\n  set readonly(value) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  _readonly = false;\n  /** Whether the input should remain interactive when it is disabled. */\n  disabledInteractive;\n  /** Whether the input is in an error state. */\n  get errorState() {\n    return this._errorStateTracker.errorState;\n  }\n  set errorState(value) {\n    this._errorStateTracker.errorState = value;\n  }\n  _neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));\n  constructor() {\n    const parentForm = inject(NgForm, {\n      optional: true\n    });\n    const parentFormGroup = inject(FormGroupDirective, {\n      optional: true\n    });\n    const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n    const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, {\n      optional: true,\n      self: true\n    });\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n    if (accessor) {\n      if (isSignal(accessor.value)) {\n        this._signalBasedValueAccessor = accessor;\n      } else {\n        this._inputValueAccessor = accessor;\n      }\n    } else {\n      // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n      this._inputValueAccessor = element;\n    }\n    this._previousNativeValue = this.value;\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (this._platform.IOS) {\n      this._ngZone.runOutsideAngular(() => {\n        this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n      });\n    }\n    this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!this._formField;\n    this.disabledInteractive = this._config?.disabledInteractive || false;\n    if (this._isNativeSelect) {\n      this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n    }\n    if (this._signalBasedValueAccessor) {\n      effect(() => {\n        // Read the value so the effect can register the dependency.\n        this._signalBasedValueAccessor.value();\n        this.stateChanges.next();\n      });\n    }\n  }\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n  ngOnDestroy() {\n    this.stateChanges.complete();\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n    this._cleanupIosKeyup?.();\n    this._cleanupWebkitWheel?.();\n  }\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n  /** Focuses the input. */\n  focus(options) {\n    this._elementRef.nativeElement.focus(options);\n  }\n  /** Refreshes the error state of the input. */\n  updateErrorState() {\n    this._errorStateTracker.updateErrorState();\n  }\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused) {\n    if (isFocused === this.focused) {\n      return;\n    }\n    if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n      const element = this._elementRef.nativeElement;\n      // Focusing an input that has text will cause all the text to be selected. Clear it since\n      // the user won't be able to change it. This is based on the internal implementation.\n      if (element.type === 'number') {\n        // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n        element.type = 'text';\n        element.setSelectionRange(0, 0);\n        element.type = 'number';\n      } else {\n        element.setSelectionRange(0, 0);\n      }\n    }\n    this.focused = isFocused;\n    this.stateChanges.next();\n  }\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n  /** Does some manual dirty checking on the native input `value` property. */\n  _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n    }\n  }\n  /** Gets the current placeholder of the form field. */\n  _getPlaceholder() {\n    return this.placeholder || null;\n  }\n  /** Make sure the input is a supported type. */\n  _validateType() {\n    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n  /** Checks whether the input type is one of the types that are never empty. */\n  _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n  /** Checks whether the input is invalid based on the native validation. */\n  _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = this._elementRef.nativeElement.validity;\n    return validity && validity.badInput;\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get empty() {\n    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get shouldLabelFloat() {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement;\n      const firstOption = selectElement.options[0];\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n    } else {\n      return this.focused && !this.disabled || !this.empty;\n    }\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  get describedByIds() {\n    const element = this._elementRef.nativeElement;\n    const existingDescribedBy = element.getAttribute('aria-describedby');\n    return existingDescribedBy?.split(' ') || [];\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  setDescribedByIds(ids) {\n    const element = this._elementRef.nativeElement;\n    if (ids.length) {\n      element.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      element.removeAttribute('aria-describedby');\n    }\n  }\n  /**\r\n   * Implemented as part of MatFormFieldControl.\r\n   * @docs-private\r\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect() {\n    const element = this._elementRef.nativeElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n  _iOSKeyupListener = event => {\n    const el = event.target;\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n  /** Gets the value to set on the `readonly` attribute. */\n  _getReadonlyAttribute() {\n    if (this._isNativeSelect) {\n      return null;\n    }\n    if (this.readonly || this.disabled && this.disabledInteractive) {\n      return 'true';\n    }\n    return null;\n  }\n  static ɵfac = function MatInput_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || MatInput)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatInput,\n    selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n    hostAttrs: [1, \"mat-mdc-input-element\"],\n    hostVars: 21,\n    hostBindings: function MatInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n          return ctx._focusChanged(true);\n        })(\"blur\", function MatInput_blur_HostBindingHandler() {\n          return ctx._focusChanged(false);\n        })(\"input\", function MatInput_input_HostBindingHandler() {\n          return ctx._onInput();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵdomProperty(\"id\", ctx.id)(\"disabled\", ctx.disabled && !ctx.disabledInteractive)(\"required\", ctx.required);\n        i0.ɵɵattribute(\"name\", ctx.name || null)(\"readonly\", ctx._getReadonlyAttribute())(\"aria-disabled\", ctx.disabled && ctx.disabledInteractive ? \"true\" : null)(\"aria-invalid\", ctx.empty && ctx.required ? null : ctx.errorState)(\"aria-required\", ctx.required)(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-mdc-form-field-textarea-control\", ctx._isInFormField && ctx._isTextarea)(\"mat-mdc-form-field-input-control\", ctx._isInFormField)(\"mat-mdc-input-disabled-interactive\", ctx.disabledInteractive)(\"mdc-text-field__input\", ctx._isInFormField)(\"mat-mdc-native-select-inline\", ctx._isInlineSelect());\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      id: \"id\",\n      placeholder: \"placeholder\",\n      name: \"name\",\n      required: \"required\",\n      type: \"type\",\n      errorStateMatcher: \"errorStateMatcher\",\n      userAriaDescribedBy: [0, \"aria-describedby\", \"userAriaDescribedBy\"],\n      value: \"value\",\n      readonly: \"readonly\",\n      disabledInteractive: [2, \"disabledInteractive\", \"disabledInteractive\", booleanAttribute]\n    },\n    exportAs: [\"matInput\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: MatInput\n    }]), i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatInput, [{\n    type: Directive,\n    args: [{\n      selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n      exportAs: 'matInput',\n      host: {\n        'class': 'mat-mdc-input-element',\n        // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n        // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n        // this MDC equivalent input.\n        '[class.mat-input-server]': '_isServer',\n        '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n        '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n        '[class.mat-mdc-input-disabled-interactive]': 'disabledInteractive',\n        '[class.mdc-text-field__input]': '_isInFormField',\n        '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n        // Native input properties that are overwritten by Angular inputs need to be synced with\n        // the native input element. Otherwise property bindings for those don't work.\n        '[id]': 'id',\n        '[disabled]': 'disabled && !disabledInteractive',\n        '[required]': 'required',\n        '[attr.name]': 'name || null',\n        '[attr.readonly]': '_getReadonlyAttribute()',\n        '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\n        // Only mark the input as invalid for assistive technology if it has a value since the\n        // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n        '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n        '[attr.aria-required]': 'required',\n        // Native input properties that are overwritten by Angular inputs need to be synced with\n        // the native input element. Otherwise property bindings for those don't work.\n        '[attr.id]': 'id',\n        '(focus)': '_focusChanged(true)',\n        '(blur)': '_focusChanged(false)',\n        '(input)': '_onInput()'\n      },\n      providers: [{\n        provide: MatFormFieldControl,\n        useExisting: MatInput\n      }]\n    }]\n  }], () => [], {\n    disabled: [{\n      type: Input\n    }],\n    id: [{\n      type: Input\n    }],\n    placeholder: [{\n      type: Input\n    }],\n    name: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    errorStateMatcher: [{\n      type: Input\n    }],\n    userAriaDescribedBy: [{\n      type: Input,\n      args: ['aria-describedby']\n    }],\n    value: [{\n      type: Input\n    }],\n    readonly: [{\n      type: Input\n    }],\n    disabledInteractive: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }]\n  });\n})();\nclass MatInputModule {\n  static ɵfac = function MatInputModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || MatInputModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MatInputModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatInputModule, [{\n    type: NgModule,\n    args: [{\n      imports: [MatCommonModule, MatFormFieldModule, MatInput],\n      exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule]\n    }]\n  }], null, null);\n})();\nexport { MAT_INPUT_CONFIG, MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };","map":{"version":3,"names":["coerceBooleanProperty","Platform","getSupportedInputTypes","AutofillMonitor","TextFieldModule","i0","InjectionToken","inject","ElementRef","NgZone","Renderer2","isSignal","effect","booleanAttribute","Directive","Input","NgModule","_IdGenerator","NgControl","Validators","NgForm","FormGroupDirective","Subject","M","MAT_INPUT_VALUE_ACCESSOR","h","MAT_FORM_FIELD","k","MatFormFieldControl","b","MatError","j","MatFormField","c","MatHint","MatLabel","e","MatPrefix","g","MatSuffix","E","ErrorStateMatcher","_","_ErrorStateTracker","MatFormFieldModule","MatCommonModule","getMatInputUnsupportedTypeError","type","Error","MAT_INPUT_INVALID_TYPES","MAT_INPUT_CONFIG","MatInput","_elementRef","_platform","ngControl","optional","self","_autofillMonitor","_ngZone","_formField","_renderer","_uid","getId","_previousNativeValue","_inputValueAccessor","_signalBasedValueAccessor","_previousPlaceholder","_errorStateTracker","_config","_cleanupIosKeyup","_cleanupWebkitWheel","_isServer","_isNativeSelect","_isTextarea","_isInFormField","focused","stateChanges","controlType","autofilled","disabled","_disabled","value","next","id","_id","placeholder","name","required","_required","control","hasValidator","_type","_validateType","has","nativeElement","errorStateMatcher","matcher","userAriaDescribedBy","set","readonly","_readonly","disabledInteractive","errorState","_neverEmptyInputTypes","filter","t","constructor","parentForm","parentFormGroup","defaultErrorStateMatcher","accessor","element","nodeName","toLowerCase","IOS","runOutsideAngular","listen","_iOSKeyupListener","isBrowser","multiple","ngAfterViewInit","monitor","subscribe","event","isAutofilled","ngOnChanges","ngOnDestroy","complete","stopMonitoring","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","setSelectionRange","_onInput","newValue","_getPlaceholder","setAttribute","removeAttribute","indexOf","ngDevMode","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","describedByIds","existingDescribedBy","getAttribute","split","setDescribedByIds","ids","length","join","onContainerClick","_isInlineSelect","size","el","target","selectionStart","selectionEnd","_getReadonlyAttribute","ɵfac","MatInput_Factory","__ngFactoryType__","ɵdir","ɵɵdefineDirective","selectors","hostAttrs","hostVars","hostBindings","MatInput_HostBindings","rf","ctx","ɵɵlistener","MatInput_focus_HostBindingHandler","MatInput_blur_HostBindingHandler","MatInput_input_HostBindingHandler","ɵɵdomProperty","ɵɵattribute","ɵɵclassProp","inputs","exportAs","features","ɵɵProvidersFeature","provide","useExisting","ɵɵNgOnChangesFeature","ɵsetClassMetadata","args","selector","host","providers","transform","MatInputModule","MatInputModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","exports"],"sources":["C:/Users/winni/OneDrive/Desktop/JINZ-Media-Full-Source/frontend/node_modules/@angular/material/fesm2022/input.mjs"],"sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { Platform, getSupportedInputTypes } from '@angular/cdk/platform';\r\nimport { AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\r\nimport * as i0 from '@angular/core';\r\nimport { InjectionToken, inject, ElementRef, NgZone, Renderer2, isSignal, effect, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\r\nimport { _IdGenerator } from '@angular/cdk/a11y';\r\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\r\nimport { Subject } from 'rxjs';\r\nimport { M as MAT_INPUT_VALUE_ACCESSOR } from './input-value-accessor-D1GvPuqO.mjs';\r\nimport { h as MAT_FORM_FIELD, k as MatFormFieldControl } from './form-field-CFbrnFED.mjs';\r\nexport { b as MatError, j as MatFormField, c as MatHint, M as MatLabel, e as MatPrefix, g as MatSuffix } from './form-field-CFbrnFED.mjs';\r\nimport { E as ErrorStateMatcher } from './error-options-DCNQlTOA.mjs';\r\nimport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\r\nimport { M as MatFormFieldModule } from './module-B62K-792.mjs';\r\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\r\nimport '@angular/cdk/bidi';\r\nimport '@angular/common';\r\nimport 'rxjs/operators';\r\nimport '@angular/cdk/observers/private';\r\nimport './animation-DfMFjxHu.mjs';\r\nimport '@angular/cdk/layout';\r\nimport '@angular/cdk/observers';\r\n\r\n/** @docs-private */\r\nfunction getMatInputUnsupportedTypeError(type) {\r\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\r\n}\r\n\r\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\r\nconst MAT_INPUT_INVALID_TYPES = [\r\n    'button',\r\n    'checkbox',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'submit',\r\n];\r\n/** Injection token that can be used to provide the default options for the input. */\r\nconst MAT_INPUT_CONFIG = new InjectionToken('MAT_INPUT_CONFIG');\r\nclass MatInput {\r\n    _elementRef = inject(ElementRef);\r\n    _platform = inject(Platform);\r\n    ngControl = inject(NgControl, { optional: true, self: true });\r\n    _autofillMonitor = inject(AutofillMonitor);\r\n    _ngZone = inject(NgZone);\r\n    _formField = inject(MAT_FORM_FIELD, { optional: true });\r\n    _renderer = inject(Renderer2);\r\n    _uid = inject(_IdGenerator).getId('mat-input-');\r\n    _previousNativeValue;\r\n    _inputValueAccessor;\r\n    _signalBasedValueAccessor;\r\n    _previousPlaceholder;\r\n    _errorStateTracker;\r\n    _config = inject(MAT_INPUT_CONFIG, { optional: true });\r\n    _cleanupIosKeyup;\r\n    _cleanupWebkitWheel;\r\n    /** Whether the component is being rendered on the server. */\r\n    _isServer;\r\n    /** Whether the component is a native html select. */\r\n    _isNativeSelect;\r\n    /** Whether the component is a textarea. */\r\n    _isTextarea;\r\n    /** Whether the input is inside of a form field. */\r\n    _isInFormField;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    focused = false;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    stateChanges = new Subject();\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    controlType = 'mat-input';\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    autofilled = false;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        // Browsers may not fire the blur event if the input is disabled too quickly.\r\n        // Reset from here to ensure that the element doesn't become stuck.\r\n        if (this.focused) {\r\n            this.focused = false;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    _disabled = false;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    set id(value) {\r\n        this._id = value || this._uid;\r\n    }\r\n    _id;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    placeholder;\r\n    /**\r\n     * Name of the input.\r\n     * @docs-private\r\n     */\r\n    name;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get required() {\r\n        return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\r\n    }\r\n    set required(value) {\r\n        this._required = coerceBooleanProperty(value);\r\n    }\r\n    _required;\r\n    /** Input type of the element. */\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    set type(value) {\r\n        this._type = value || 'text';\r\n        this._validateType();\r\n        // When using Angular inputs, developers are no longer able to set the properties on the native\r\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\r\n        // with the native property. Textarea elements don't support the type property or attribute.\r\n        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\r\n            this._elementRef.nativeElement.type = this._type;\r\n        }\r\n    }\r\n    _type = 'text';\r\n    /** An object used to control when error messages are shown. */\r\n    get errorStateMatcher() {\r\n        return this._errorStateTracker.matcher;\r\n    }\r\n    set errorStateMatcher(value) {\r\n        this._errorStateTracker.matcher = value;\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    userAriaDescribedBy;\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get value() {\r\n        return this._signalBasedValueAccessor\r\n            ? this._signalBasedValueAccessor.value()\r\n            : this._inputValueAccessor.value;\r\n    }\r\n    set value(value) {\r\n        if (value !== this.value) {\r\n            if (this._signalBasedValueAccessor) {\r\n                this._signalBasedValueAccessor.value.set(value);\r\n            }\r\n            else {\r\n                this._inputValueAccessor.value = value;\r\n            }\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /** Whether the element is readonly. */\r\n    get readonly() {\r\n        return this._readonly;\r\n    }\r\n    set readonly(value) {\r\n        this._readonly = coerceBooleanProperty(value);\r\n    }\r\n    _readonly = false;\r\n    /** Whether the input should remain interactive when it is disabled. */\r\n    disabledInteractive;\r\n    /** Whether the input is in an error state. */\r\n    get errorState() {\r\n        return this._errorStateTracker.errorState;\r\n    }\r\n    set errorState(value) {\r\n        this._errorStateTracker.errorState = value;\r\n    }\r\n    _neverEmptyInputTypes = [\r\n        'date',\r\n        'datetime',\r\n        'datetime-local',\r\n        'month',\r\n        'time',\r\n        'week',\r\n    ].filter(t => getSupportedInputTypes().has(t));\r\n    constructor() {\r\n        const parentForm = inject(NgForm, { optional: true });\r\n        const parentFormGroup = inject(FormGroupDirective, { optional: true });\r\n        const defaultErrorStateMatcher = inject(ErrorStateMatcher);\r\n        const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, { optional: true, self: true });\r\n        const element = this._elementRef.nativeElement;\r\n        const nodeName = element.nodeName.toLowerCase();\r\n        if (accessor) {\r\n            if (isSignal(accessor.value)) {\r\n                this._signalBasedValueAccessor = accessor;\r\n            }\r\n            else {\r\n                this._inputValueAccessor = accessor;\r\n            }\r\n        }\r\n        else {\r\n            // If no input value accessor was explicitly specified, use the element as the input value\r\n            // accessor.\r\n            this._inputValueAccessor = element;\r\n        }\r\n        this._previousNativeValue = this.value;\r\n        // Force setter to be called in case id was not specified.\r\n        this.id = this.id;\r\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\r\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\r\n        // exists on iOS, we only bother to install the listener on iOS.\r\n        if (this._platform.IOS) {\r\n            this._ngZone.runOutsideAngular(() => {\r\n                this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\r\n            });\r\n        }\r\n        this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\r\n        this._isServer = !this._platform.isBrowser;\r\n        this._isNativeSelect = nodeName === 'select';\r\n        this._isTextarea = nodeName === 'textarea';\r\n        this._isInFormField = !!this._formField;\r\n        this.disabledInteractive = this._config?.disabledInteractive || false;\r\n        if (this._isNativeSelect) {\r\n            this.controlType = element.multiple\r\n                ? 'mat-native-select-multiple'\r\n                : 'mat-native-select';\r\n        }\r\n        if (this._signalBasedValueAccessor) {\r\n            effect(() => {\r\n                // Read the value so the effect can register the dependency.\r\n                this._signalBasedValueAccessor.value();\r\n                this.stateChanges.next();\r\n            });\r\n        }\r\n    }\r\n    ngAfterViewInit() {\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\r\n                this.autofilled = event.isAutofilled;\r\n                this.stateChanges.next();\r\n            });\r\n        }\r\n    }\r\n    ngOnChanges() {\r\n        this.stateChanges.next();\r\n    }\r\n    ngOnDestroy() {\r\n        this.stateChanges.complete();\r\n        if (this._platform.isBrowser) {\r\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n        }\r\n        this._cleanupIosKeyup?.();\r\n        this._cleanupWebkitWheel?.();\r\n    }\r\n    ngDoCheck() {\r\n        if (this.ngControl) {\r\n            // We need to re-evaluate this on every change detection cycle, because there are some\r\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\r\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\r\n            this.updateErrorState();\r\n            // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\r\n            // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\r\n            // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\r\n            // disabled.\r\n            if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\r\n                this.disabled = this.ngControl.disabled;\r\n                this.stateChanges.next();\r\n            }\r\n        }\r\n        // We need to dirty-check the native element's value, because there are some cases where\r\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\r\n        // updating the value using `emitEvent: false`).\r\n        this._dirtyCheckNativeValue();\r\n        // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\r\n        // present or not depends on a query which is prone to \"changed after checked\" errors.\r\n        this._dirtyCheckPlaceholder();\r\n    }\r\n    /** Focuses the input. */\r\n    focus(options) {\r\n        this._elementRef.nativeElement.focus(options);\r\n    }\r\n    /** Refreshes the error state of the input. */\r\n    updateErrorState() {\r\n        this._errorStateTracker.updateErrorState();\r\n    }\r\n    /** Callback for the cases where the focused state of the input changes. */\r\n    _focusChanged(isFocused) {\r\n        if (isFocused === this.focused) {\r\n            return;\r\n        }\r\n        if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\r\n            const element = this._elementRef.nativeElement;\r\n            // Focusing an input that has text will cause all the text to be selected. Clear it since\r\n            // the user won't be able to change it. This is based on the internal implementation.\r\n            if (element.type === 'number') {\r\n                // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\r\n                element.type = 'text';\r\n                element.setSelectionRange(0, 0);\r\n                element.type = 'number';\r\n            }\r\n            else {\r\n                element.setSelectionRange(0, 0);\r\n            }\r\n        }\r\n        this.focused = isFocused;\r\n        this.stateChanges.next();\r\n    }\r\n    _onInput() {\r\n        // This is a noop function and is used to let Angular know whenever the value changes.\r\n        // Angular will run a new change detection each time the `input` event has been dispatched.\r\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\r\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\r\n        // value changes and will not disappear.\r\n        // Listening to the input event wouldn't be necessary when the input is using the\r\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\r\n    }\r\n    /** Does some manual dirty checking on the native input `value` property. */\r\n    _dirtyCheckNativeValue() {\r\n        const newValue = this._elementRef.nativeElement.value;\r\n        if (this._previousNativeValue !== newValue) {\r\n            this._previousNativeValue = newValue;\r\n            this.stateChanges.next();\r\n        }\r\n    }\r\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\r\n    _dirtyCheckPlaceholder() {\r\n        const placeholder = this._getPlaceholder();\r\n        if (placeholder !== this._previousPlaceholder) {\r\n            const element = this._elementRef.nativeElement;\r\n            this._previousPlaceholder = placeholder;\r\n            placeholder\r\n                ? element.setAttribute('placeholder', placeholder)\r\n                : element.removeAttribute('placeholder');\r\n        }\r\n    }\r\n    /** Gets the current placeholder of the form field. */\r\n    _getPlaceholder() {\r\n        return this.placeholder || null;\r\n    }\r\n    /** Make sure the input is a supported type. */\r\n    _validateType() {\r\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getMatInputUnsupportedTypeError(this._type);\r\n        }\r\n    }\r\n    /** Checks whether the input type is one of the types that are never empty. */\r\n    _isNeverEmpty() {\r\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\r\n    }\r\n    /** Checks whether the input is invalid based on the native validation. */\r\n    _isBadInput() {\r\n        // The `validity` property won't be present on platform-server.\r\n        let validity = this._elementRef.nativeElement.validity;\r\n        return validity && validity.badInput;\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get empty() {\r\n        return (!this._isNeverEmpty() &&\r\n            !this._elementRef.nativeElement.value &&\r\n            !this._isBadInput() &&\r\n            !this.autofilled);\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get shouldLabelFloat() {\r\n        if (this._isNativeSelect) {\r\n            // For a single-selection `<select>`, the label should float when the selected option has\r\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\r\n            // overlapping the label with the options.\r\n            const selectElement = this._elementRef.nativeElement;\r\n            const firstOption = selectElement.options[0];\r\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\r\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\r\n            return (this.focused ||\r\n                selectElement.multiple ||\r\n                !this.empty ||\r\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label));\r\n        }\r\n        else {\r\n            return (this.focused && !this.disabled) || !this.empty;\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    get describedByIds() {\r\n        const element = this._elementRef.nativeElement;\r\n        const existingDescribedBy = element.getAttribute('aria-describedby');\r\n        return existingDescribedBy?.split(' ') || [];\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    setDescribedByIds(ids) {\r\n        const element = this._elementRef.nativeElement;\r\n        if (ids.length) {\r\n            element.setAttribute('aria-describedby', ids.join(' '));\r\n        }\r\n        else {\r\n            element.removeAttribute('aria-describedby');\r\n        }\r\n    }\r\n    /**\r\n     * Implemented as part of MatFormFieldControl.\r\n     * @docs-private\r\n     */\r\n    onContainerClick() {\r\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\r\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\r\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\r\n        if (!this.focused) {\r\n            this.focus();\r\n        }\r\n    }\r\n    /** Whether the form control is a native select that is displayed inline. */\r\n    _isInlineSelect() {\r\n        const element = this._elementRef.nativeElement;\r\n        return this._isNativeSelect && (element.multiple || element.size > 1);\r\n    }\r\n    _iOSKeyupListener = (event) => {\r\n        const el = event.target;\r\n        // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\r\n        // indicate different things. If the value is 0, it means that the caret is at the start\r\n        // of the input, whereas a value of `null` means that the input doesn't support\r\n        // manipulating the selection range. Inputs that don't support setting the selection range\r\n        // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\r\n        // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\r\n        if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\r\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\r\n            // `1, 1` fixes it for the first time that you type text and\r\n            // then hold delete. Toggling to `1, 1` and then back to\r\n            // `0, 0` seems to completely fix it.\r\n            el.setSelectionRange(1, 1);\r\n            el.setSelectionRange(0, 0);\r\n        }\r\n    };\r\n    /** Gets the value to set on the `readonly` attribute. */\r\n    _getReadonlyAttribute() {\r\n        if (this._isNativeSelect) {\r\n            return null;\r\n        }\r\n        if (this.readonly || (this.disabled && this.disabledInteractive)) {\r\n            return 'true';\r\n        }\r\n        return null;\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInput, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.0.0\", type: MatInput, isStandalone: true, selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\", inputs: { disabled: \"disabled\", id: \"id\", placeholder: \"placeholder\", name: \"name\", required: \"required\", type: \"type\", errorStateMatcher: \"errorStateMatcher\", userAriaDescribedBy: [\"aria-describedby\", \"userAriaDescribedBy\"], value: \"value\", readonly: \"readonly\", disabledInteractive: [\"disabledInteractive\", \"disabledInteractive\", booleanAttribute] }, host: { listeners: { \"focus\": \"_focusChanged(true)\", \"blur\": \"_focusChanged(false)\", \"input\": \"_onInput()\" }, properties: { \"class.mat-input-server\": \"_isServer\", \"class.mat-mdc-form-field-textarea-control\": \"_isInFormField && _isTextarea\", \"class.mat-mdc-form-field-input-control\": \"_isInFormField\", \"class.mat-mdc-input-disabled-interactive\": \"disabledInteractive\", \"class.mdc-text-field__input\": \"_isInFormField\", \"class.mat-mdc-native-select-inline\": \"_isInlineSelect()\", \"id\": \"id\", \"disabled\": \"disabled && !disabledInteractive\", \"required\": \"required\", \"attr.name\": \"name || null\", \"attr.readonly\": \"_getReadonlyAttribute()\", \"attr.aria-disabled\": \"disabled && disabledInteractive ? \\\"true\\\" : null\", \"attr.aria-invalid\": \"(empty && required) ? null : errorState\", \"attr.aria-required\": \"required\", \"attr.id\": \"id\" }, classAttribute: \"mat-mdc-input-element\" }, providers: [{ provide: MatFormFieldControl, useExisting: MatInput }], exportAs: [\"matInput\"], usesOnChanges: true, ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInput, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: `input[matInput], textarea[matInput], select[matNativeControl],\r\n      input[matNativeControl], textarea[matNativeControl]`,\r\n                    exportAs: 'matInput',\r\n                    host: {\r\n                        'class': 'mat-mdc-input-element',\r\n                        // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\r\n                        // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\r\n                        // this MDC equivalent input.\r\n                        '[class.mat-input-server]': '_isServer',\r\n                        '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\r\n                        '[class.mat-mdc-form-field-input-control]': '_isInFormField',\r\n                        '[class.mat-mdc-input-disabled-interactive]': 'disabledInteractive',\r\n                        '[class.mdc-text-field__input]': '_isInFormField',\r\n                        '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\r\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\r\n                        // the native input element. Otherwise property bindings for those don't work.\r\n                        '[id]': 'id',\r\n                        '[disabled]': 'disabled && !disabledInteractive',\r\n                        '[required]': 'required',\r\n                        '[attr.name]': 'name || null',\r\n                        '[attr.readonly]': '_getReadonlyAttribute()',\r\n                        '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\r\n                        // Only mark the input as invalid for assistive technology if it has a value since the\r\n                        // state usually overlaps with `aria-required` when the input is empty and can be redundant.\r\n                        '[attr.aria-invalid]': '(empty && required) ? null : errorState',\r\n                        '[attr.aria-required]': 'required',\r\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\r\n                        // the native input element. Otherwise property bindings for those don't work.\r\n                        '[attr.id]': 'id',\r\n                        '(focus)': '_focusChanged(true)',\r\n                        '(blur)': '_focusChanged(false)',\r\n                        '(input)': '_onInput()',\r\n                    },\r\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\r\n                }]\r\n        }], ctorParameters: () => [], propDecorators: { disabled: [{\r\n                type: Input\r\n            }], id: [{\r\n                type: Input\r\n            }], placeholder: [{\r\n                type: Input\r\n            }], name: [{\r\n                type: Input\r\n            }], required: [{\r\n                type: Input\r\n            }], type: [{\r\n                type: Input\r\n            }], errorStateMatcher: [{\r\n                type: Input\r\n            }], userAriaDescribedBy: [{\r\n                type: Input,\r\n                args: ['aria-describedby']\r\n            }], value: [{\r\n                type: Input\r\n            }], readonly: [{\r\n                type: Input\r\n            }], disabledInteractive: [{\r\n                type: Input,\r\n                args: [{ transform: booleanAttribute }]\r\n            }] } });\r\n\r\nclass MatInputModule {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatInput], exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule] });\r\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule] });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatInputModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [MatCommonModule, MatFormFieldModule, MatInput],\r\n                    exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\r\n                }]\r\n        }] });\r\n\r\nexport { MAT_INPUT_CONFIG, MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}